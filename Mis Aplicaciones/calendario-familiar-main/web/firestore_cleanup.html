<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firestore Cleanup - Limpieza de Datos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #f44336;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
        }

        .danger-warning {
            background: #ffebee;
            color: #c62828;
            border: 2px solid #f44336;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .danger-warning strong {
            display: block;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .danger-warning ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 6px;
            border-left: 4px solid #1976D2;
        }

        .section.danger {
            border-left-color: #f44336;
        }

        .section.warning {
            border-left-color: #ff9800;
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
        }

        .collection-info {
            background: white;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #4CAF50;
        }

        .collection-info.unused {
            border-left-color: #f44336;
        }

        .collection-info.partial {
            border-left-color: #ff9800;
        }

        .collection-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 8px;
        }

        .collection-details {
            font-size: 14px;
            color: #666;
            margin: 5px 0;
        }

        .field-list {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }

        .field-item {
            padding: 5px;
            font-size: 12px;
            color: #333;
        }

        .field-item.used {
            color: #4CAF50;
        }

        .field-item.unused {
            color: #f44336;
        }

        .button {
            background: #f44336;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background 0.3s;
        }

        .button:hover {
            background: #d32f2f;
        }

        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .button-secondary {
            background: #1976D2;
        }

        .button-secondary:hover {
            background: #1565C0;
        }

        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            display: block;
        }

        .progress {
            margin-top: 15px;
            padding: 12px;
            background: #e3f2fd;
            border-radius: 6px;
            display: none;
        }

        .progress.show {
            display: block;
        }

        .progress-text {
            margin-bottom: 8px;
            color: #1976D2;
            font-weight: 500;
        }

        .progress-bar {
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1976D2;
            width: 0%;
            transition: width 0.3s;
        }

        .checkbox-container {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
            cursor: pointer;
        }

        .checkbox-container input {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üßπ Firestore Cleanup - Limpieza de Datos</h1>
        <p class="subtitle">Elimina colecciones y campos no utilizados por la aplicaci√≥n</p>

        <div class="danger-warning">
            <strong>‚ö†Ô∏è ADVERTENCIA CR√çTICA:</strong>
            <ul>
                <li><strong>HAZ BACKUP ANTES DE CONTINUAR</strong> - Usa firestore_backup.html primero</li>
                <li>Esta herramienta ELIMINAR√Å datos permanentemente</li>
                <li>No se puede deshacer despu√©s de eliminar</li>
                <li>Verifica que el backup se descarg√≥ correctamente</li>
                <li>Esta operaci√≥n es IRREVERSIBLE</li>
            </ul>
        </div>

        <!-- ANALYSIS SECTION -->
        <div class="section">
            <h2>üìä An√°lisis de Base de Datos</h2>
            <p style="margin-bottom: 15px;">Analiza qu√© colecciones y campos se utilizan en la aplicaci√≥n.</p>
            
            <button class="button button-secondary" onclick="analyzeDatabase()" id="analyzeBtn">
                üîç Analizar Base de Datos
            </button>

            <div class="status" id="analyzeStatus"></div>

            <div id="analysisResults" style="display: none;">
                <h3 style="margin-top: 20px; margin-bottom: 10px;">Resultados del An√°lisis:</h3>
                <div id="collectionsAnalysis"></div>
            </div>
        </div>

        <!-- CLEANUP SECTION -->
        <div class="section danger">
            <h2>üóëÔ∏è Limpiar Datos No Utilizados</h2>
            <p style="margin-bottom: 15px;">Elimina colecciones y campos que no se usan en la aplicaci√≥n.</p>
            
            <p style="margin-bottom: 15px; font-weight: bold; color: #f44336;">
                Primero debes hacer un an√°lisis para ver qu√© se puede eliminar.
            </p>

            <div id="cleanupOptions" style="display: none;">
                <h3 style="margin-bottom: 15px;">Opciones de Limpieza:</h3>
                
                <div class="checkbox-container">
                    <label>
                        <input type="checkbox" id="deleteUnusedCollections" checked>
                        <strong>Eliminar colecciones no utilizadas completamente</strong>
                    </label>
                    <p style="font-size: 12px; color: #666; margin-top: 5px; margin-left: 24px;">
                        Elimina: shift_templates (ya migrado a shifts), y otras colecciones no usadas
                    </p>
                </div>

                <div class="checkbox-container">
                    <label>
                        <input type="checkbox" id="cleanUnusedFields" checked>
                        <strong>Limpiar campos no utilizados en documentos</strong>
                    </label>
                    <p style="font-size: 12px; color: #666; margin-top: 5px; margin-left: 24px;">
                        Elimina campos que la app no lee (mantiene solo los campos utilizados)
                    </p>
                </div>

                <button class="button" onclick="executeCleanup()" id="cleanupBtn">
                    üóëÔ∏è Ejecutar Limpieza
                </button>
            </div>

            <div class="status" id="cleanupStatus"></div>
            
            <div class="progress" id="cleanupProgress">
                <div class="progress-text" id="cleanupProgressText">Preparando limpieza...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="cleanupProgressFill"></div>
                </div>
            </div>
        </div>

        <!-- MIGRATION SECTION -->
        <div class="section">
            <h2>üîß Migraci√≥n Autom√°tica (Turnos y Eventos)</h2>
            <p style="margin-bottom: 15px;">Normaliza turnos y eventos del calendario para evitar duplicados y colores grises.</p>

            <div class="checkbox-container">
                <label>
                    <input type="checkbox" id="migrateShiftTemplates" checked>
                    <strong>Mover turnos de shift_templates ‚Üí shifts (si existen)</strong>
                </label>
            </div>

            <div class="checkbox-container">
                <label>
                    <input type="checkbox" id="normalizeCalendarEvents" checked>
                    <strong>Normalizar calendar_events (a√±adir shiftId, estandarizar texto y color)</strong>
                </label>
            </div>

            <button class="button button-secondary" onclick="runMigration()" id="migrateBtn">üöÄ Ejecutar Migraci√≥n Autom√°tica</button>

            <div class="status" id="migrateStatus"></div>
            <div class="progress" id="migrateProgress">
                <div class="progress-text" id="migrateProgressText">Preparando migraci√≥n...</div>
                <div class="progress-bar"><div class="progress-fill" id="migrateProgressFill"></div></div>
            </div>
        </div>

        <!-- FULL RESET SECTION -->
        <div class="section danger">
            <h2>üß® Reset TOTAL de la Base de Datos</h2>
            <p style="margin-bottom: 10px;">Borra todas las colecciones relacionadas y (opcional) crea una semilla m√≠nima de turnos.</p>

            <div class="checkbox-container">
                <label>
                    <input type="checkbox" id="seedAfterReset" checked>
                    <strong>Sembrar turnos por defecto tras el borrado (recomendado)</strong>
                </label>
                <p style="font-size:12px; color:#666; margin-left:24px;">Crea 4 turnos: D1, D2, Libre, Oper</p>
            </div>

            <button class="button" onclick="resetDatabase()" id="resetBtn">üß® Borrar TODO y Reiniciar</button>
            <div class="status" id="resetStatus"></div>
            <div class="progress" id="resetProgress">
                <div class="progress-text" id="resetProgressText">Preparando...</div>
                <div class="progress-bar"><div class="progress-fill" id="resetProgressFill"></div></div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>

    <script>
        // Configuraci√≥n de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyB5vvp7IQOZLO7LlsUY_Wq-H8M_5PH3ZQE",
            authDomain: "apptaxi-f2190.firebaseapp.com",
            projectId: "apptaxi-f2190",
            storageBucket: "apptaxi-f2190.firebasestorage.app",
            messagingSenderId: "804273724178",
            appId: "1:804273724178:web:c5955a1f657884c0e7f1cb",
            measurementId: "G-3D8R30TYTM"
        };

        // Inicializar Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Definici√≥n de qu√© usa la app
        const APP_REQUIREMENTS = {
            // Colecciones que S√ç se usan
            usedCollections: {
                'calendar_events': {
                    requiredFields: ['events', 'lastModified', 'modifiedBy'],
                    eventFields: ['text', 'userId', 'createdAt', 'categories', 'type']
                },
                'shifts': {
                    requiredFields: ['name', 'colorHex', 'abbreviation', 'startTime', 'endTime']
                }
            },
            // Colecciones que NO se usan (se pueden eliminar)
            unusedCollections: [
                'shift_templates', // Ya migrado a 'shifts'
                'alarms',
                'dayCategories',
                'families',
                'local_users',
                'notes', // Los datos est√°n en calendar_events como type='note'
                'users' // Si no se usa autenticaci√≥n con usuarios
            ]
        };

        let analysisResults = null;

        // Analizar base de datos
        async function analyzeDatabase() {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const analyzeStatus = document.getElementById('analyzeStatus');
            const analysisResults = document.getElementById('analysisResults');
            const collectionsAnalysis = document.getElementById('collectionsAnalysis');

            try {
                analyzeBtn.disabled = true;
                analyzeStatus.className = 'status info';
                analyzeStatus.textContent = '‚è≥ Analizando base de datos... Esto puede tardar unos minutos.';
                analyzeStatus.style.display = 'block';

                const analysis = {
                    used: {},
                    unused: {},
                    partial: {}
                };

                // Analizar colecciones usadas
                for (const [collectionName, structure] of Object.entries(APP_REQUIREMENTS.usedCollections)) {
                    try {
                        const snapshot = await db.collection(collectionName).limit(5).get();
                        if (!snapshot.empty) {
                            const sampleDoc = snapshot.docs[0].data();
                            const foundFields = Object.keys(sampleDoc);
                            const unusedFields = foundFields.filter(f => !structure.requiredFields.includes(f));
                            
                            const docCount = (await db.collection(collectionName).get()).size;
                            
                            analysis.used[collectionName] = {
                                docCount,
                                structure,
                                foundFields,
                                unusedFields
                            };
                        }
                    } catch (error) {
                        console.warn(`Error analizando ${collectionName}:`, error);
                    }
                }

                // Analizar colecciones no usadas
                for (const collectionName of APP_REQUIREMENTS.unusedCollections) {
                    try {
                        const snapshot = await db.collection(collectionName).get();
                        const docCount = snapshot.size;
                        if (docCount > 0) {
                            analysis.unused[collectionName] = { docCount };
                        }
                    } catch (error) {
                        // Colecci√≥n no existe o no se puede acceder
                    }
                }

                // Mostrar resultados
                collectionsAnalysis.innerHTML = '';
                
                // Colecciones usadas
                if (Object.keys(analysis.used).length > 0) {
                    const usedDiv = document.createElement('div');
                    usedDiv.innerHTML = '<h4 style="color: #4CAF50; margin-top: 15px;">‚úÖ Colecciones Usadas:</h4>';
                    collectionsAnalysis.appendChild(usedDiv);
                    
                    for (const [name, info] of Object.entries(analysis.used)) {
                        const div = document.createElement('div');
                        div.className = 'collection-info';
                        let html = `
                            <div class="collection-name">üìÅ ${name}</div>
                            <div class="collection-details">Documentos: ${info.docCount}</div>
                        `;
                        
                        if (info.unusedFields.length > 0) {
                            html += `
                                <div class="field-list">
                                    <strong>‚ö†Ô∏è Campos no utilizados encontrados:</strong>
                                    ${info.unusedFields.map(f => `<div class="field-item unused">‚ùå ${f}</div>`).join('')}
                                </div>
                            `;
                        }
                        
                        div.innerHTML = html;
                        collectionsAnalysis.appendChild(div);
                    }
                }

                // Colecciones no usadas
                if (Object.keys(analysis.unused).length > 0) {
                    const unusedDiv = document.createElement('div');
                    unusedDiv.innerHTML = '<h4 style="color: #f44336; margin-top: 15px;">‚ùå Colecciones No Usadas (se pueden eliminar):</h4>';
                    collectionsAnalysis.appendChild(unusedDiv);
                    
                    for (const [name, info] of Object.entries(analysis.unused)) {
                        const div = document.createElement('div');
                        div.className = 'collection-info unused';
                        div.innerHTML = `
                            <div class="collection-name">üóëÔ∏è ${name}</div>
                            <div class="collection-details">${info.docCount} documentos - Se pueden eliminar completamente</div>
                        `;
                        collectionsAnalysis.appendChild(div);
                    }
                }

                analysisResults.style.display = 'block';
                window.analysisResults = analysis;

                analyzeStatus.className = 'status success';
                analyzeStatus.textContent = '‚úÖ An√°lisis completado. Revisa los resultados abajo.';
                
                // Mostrar opciones de limpieza
                const cleanupOptions = document.getElementById('cleanupOptions');
                cleanupOptions.style.display = 'block';

            } catch (error) {
                console.error('Error en an√°lisis:', error);
                analyzeStatus.className = 'status error';
                analyzeStatus.textContent = `‚ùå Error en an√°lisis: ${error.message}`;
            } finally {
                analyzeBtn.disabled = false;
            }
        }

        // Ejecutar limpieza
        async function executeCleanup() {
            if (!window.analysisResults) {
                alert('Primero debes hacer un an√°lisis de la base de datos.');
                return;
            }

            if (!confirm('‚ö†Ô∏è CONFIRMACI√ìN FINAL:\n\nEsto ELIMINAR√Å datos permanentemente.\n¬øEst√°s 100% seguro de continuar?\n\nAseg√∫rate de haber hecho backup primero.')) {
                return;
            }

            if (!confirm('‚ö†Ô∏è √öLTIMA CONFIRMACI√ìN:\n\nEsta operaci√≥n es IRREVERSIBLE.\n¬øRealmente quieres eliminar los datos?')) {
                return;
            }

            const cleanupBtn = document.getElementById('cleanupBtn');
            const cleanupStatus = document.getElementById('cleanupStatus');
            const cleanupProgress = document.getElementById('cleanupProgress');
            const cleanupProgressText = document.getElementById('cleanupProgressText');
            const cleanupProgressFill = document.getElementById('cleanupProgressFill');
            
            const deleteUnusedCollections = document.getElementById('deleteUnusedCollections').checked;
            const cleanUnusedFields = document.getElementById('cleanUnusedFields').checked;

            try {
                cleanupBtn.disabled = true;
                cleanupStatus.className = 'status info';
                cleanupStatus.textContent = '‚è≥ Iniciando limpieza...';
                cleanupStatus.style.display = 'block';
                cleanupProgress.classList.add('show');

                let deletedCollections = 0;
                let cleanedDocuments = 0;

                // Eliminar colecciones no usadas
                if (deleteUnusedCollections && window.analysisResults.unused) {
                    const unusedCollections = Object.keys(window.analysisResults.unused);
                    let current = 0;
                    
                    for (const collectionName of unusedCollections) {
                        current++;
                        cleanupProgressText.textContent = `Eliminando colecci√≥n ${current}/${unusedCollections.length}: ${collectionName}...`;
                        
                        try {
                            // Obtener todos los documentos
                            const snapshot = await db.collection(collectionName).get();
                            
                            // Eliminar en lotes
                            const batch = db.batch();
                            snapshot.docs.forEach(doc => {
                                batch.delete(doc.ref);
                            });
                            
                            await batch.commit();
                            deletedCollections++;
                            
                            cleanupProgressFill.style.width = `${(current / unusedCollections.length) * 50}%`;
                        } catch (error) {
                            console.error(`Error eliminando ${collectionName}:`, error);
                        }
                    }
                }

                // Limpiar campos no usados en documentos
                if (cleanUnusedFields && window.analysisResults.used) {
                    const usedCollections = Object.keys(window.analysisResults.used);
                    let current = 0;
                    const total = usedCollections.length;
                    
                    for (const collectionName of usedCollections) {
                        current++;
                        cleanupProgressText.textContent = `Limpiando campos en ${current}/${total}: ${collectionName}...`;
                        
                        try {
                            const info = window.analysisResults.used[collectionName];
                            const snapshot = await db.collection(collectionName).get();
                            
                            if (info.unusedFields.length > 0) {
                                const batch = db.batch();
                                snapshot.docs.forEach(doc => {
                                    const data = doc.data();
                                    const update = {};
                                    info.unusedFields.forEach(field => {
                                        update[field] = firebase.firestore.FieldValue.delete();
                                    });
                                    batch.update(doc.ref, update);
                                });
                                await batch.commit();
                                cleanedDocuments += snapshot.size;
                            }
                            
                            cleanupProgressFill.style.width = `${50 + (current / total) * 50}%`;
                        } catch (error) {
                            console.error(`Error limpiando ${collectionName}:`, error);
                        }
                    }
                }

                cleanupProgressFill.style.width = '100%';
                cleanupProgressText.textContent = '‚úÖ Limpieza completada!';

                cleanupStatus.className = 'status success';
                cleanupStatus.textContent = `‚úÖ Limpieza completada!\n\n- ${deletedCollections} colecciones eliminadas\n- ${cleanedDocuments} documentos limpiados`;

                setTimeout(() => {
                    cleanupProgress.classList.remove('show');
                }, 2000);

            } catch (error) {
                console.error('Error en limpieza:', error);
                cleanupStatus.className = 'status error';
                cleanupStatus.textContent = `‚ùå Error en limpieza: ${error.message}`;
            } finally {
                cleanupBtn.disabled = false;
            }
        }

        // ---------- MIGRACI√ìN AUTOM√ÅTICA ----------
        function normalizeKey(s){ return (s||'').toString().trim().toLowerCase(); }

        async function loadShiftsMap(){
            const mapById = new Map();
            const mapByName = new Map();
            const snap = await db.collection('shifts').get();
            snap.docs.forEach(d=>{
                const data=d.data();
                const rec={ id:d.id, ...data };
                mapById.set(d.id, rec);
                mapByName.set(normalizeKey(data.name), rec);
                mapByName.set(normalizeKey(data.abbreviation), rec);
            });
            return {mapById, mapByName};
        }

        async function migrateShiftTemplatesIntoShifts(progress){
            try{
                const tmpSnap = await db.collection('shift_templates').get();
                if (tmpSnap.empty) return {moved:0};
                let moved=0;
                const {mapByName}=await loadShiftsMap();
                for (const doc of tmpSnap.docs){
                    const data=doc.data();
                    const keyA=normalizeKey(data.abbreviation), keyN=normalizeKey(data.name);
                    if (!mapByName.has(keyA) && !mapByName.has(keyN)){
                        const newRef = db.collection('shifts').doc();
                        await newRef.set(data);
                        moved++;
                    }
                }
                progress(`Turnos migrados: ${moved}`);
                return {moved};
            }catch(e){ console.error('migrateShiftTemplatesIntoShifts',e); return {moved:0,error:e}; }
        }

        async function normalizeCalendarEventsDocs(progress){
            let updated=0, scanned=0;
            const {mapById, mapByName}=await loadShiftsMap();
            const snap = await db.collection('calendar_events').get();
            for (const doc of snap.docs){
                scanned++;
                const data = doc.data();
                const events = Array.isArray(data.events)? [...data.events] : [];
                let changed=false;
                for (const ev of events){
                    if (ev && ev.type !== 'note'){
                        if (!ev.shiftId){
                            const rec = mapByName.get(normalizeKey(ev.text));
                            if (rec){ ev.shiftId = rec.id; ev.text = rec.abbreviation || rec.name; ev.userColor = ev.userColor || rec.backgroundColor || rec.colorHex || rec.color; changed=true; }
                        } else {
                            const rec = mapById.get(ev.shiftId) || mapByName.get(normalizeKey(ev.text));
                            if (rec){
                                const newText = rec.abbreviation || rec.name;
                                const newColor = rec.backgroundColor || rec.colorHex || rec.color;
                                if (ev.text !== newText){ ev.text=newText; changed=true; }
                                if (!ev.userColor && newColor){ ev.userColor=newColor; changed=true; }
                            }
                        }
                    }
                }
                if (changed){
                    await doc.ref.set({
                        events,
                        lastModified: firebase.firestore.FieldValue.serverTimestamp()
                    }, {merge:true});
                    updated++;
                }
                if (scanned % 50 === 0) progress(`Procesados ${scanned}/${snap.size} d√≠as...`);
            }
            progress(`Eventos normalizados: ${updated}`);
            return {updated, scanned:snap.size};
        }

        async function runMigration(){
            const migrateBtn=document.getElementById('migrateBtn');
            const migrateStatus=document.getElementById('migrateStatus');
            const migrateProgress=document.getElementById('migrateProgress');
            const migrateProgressText=document.getElementById('migrateProgressText');
            const migrateProgressFill=document.getElementById('migrateProgressFill');

            function setProgress(t, ratio){ migrateProgressText.textContent=t; if (ratio!=null) migrateProgressFill.style.width = `${Math.max(1,Math.min(100,ratio*100))}%`; }

            try{
                migrateBtn.disabled=true; migrateProgress.classList.add('show');
                migrateStatus.className='status info'; migrateStatus.style.display='block'; migrateStatus.textContent='‚è≥ Ejecutando migraci√≥n...';

                let steps=0, done=0; const wantMove=document.getElementById('migrateShiftTemplates').checked; const wantNormalize=document.getElementById('normalizeCalendarEvents').checked;
                steps += wantMove?1:0; steps += wantNormalize?1:0; if (steps===0) { migrateStatus.className='status error'; migrateStatus.textContent='Selecciona al menos una opci√≥n.'; return; }

                if (wantMove){
                    await migrateShiftTemplatesIntoShifts(msg=>setProgress(`Migrando turnos: ${msg}`, (done+0.5)/steps));
                    done+=1; setProgress('Turnos migrados', done/steps);
                }
                if (wantNormalize){
                    await normalizeCalendarEventsDocs(msg=>setProgress(`Normalizando eventos: ${msg}`, (done+0.5)/steps));
                    done+=1; setProgress('Eventos normalizados', done/steps);
                }

                migrateStatus.className='status success';
                migrateStatus.textContent='‚úÖ Migraci√≥n completada. Abre el calendario y la vista 2025 para verificar colores y totales.';
            }catch(e){
                console.error('runMigration',e);
                migrateStatus.className='status error'; migrateStatus.textContent=`‚ùå Error en migraci√≥n: ${e.message}`;
            }finally{
                migrateBtn.disabled=false;
                setTimeout(()=>migrateProgress.classList.remove('show'), 2000);
            }
        }

        // ---------- RESET TOTAL ----------
        async function resetDatabase(){
            const resetBtn=document.getElementById('resetBtn');
            const resetStatus=document.getElementById('resetStatus');
            const resetProgress=document.getElementById('resetProgress');
            const resetProgressText=document.getElementById('resetProgressText');
            const resetProgressFill=document.getElementById('resetProgressFill');

            const seed = document.getElementById('seedAfterReset').checked;

            if (!confirm('‚ö†Ô∏è Esto borrar√° TODA la base de datos de la app (calendar_events, shifts, users, shift_templates, local_users, families, etc.). ¬øContinuar?')) return;
            if (!confirm('‚ö†Ô∏è √öLTIMA CONFIRMACI√ìN: Operaci√≥n IRREVERSIBLE. ¬øSeguro que deseas borrar todo?')) return;

            function setProgress(t, ratio){ resetProgressText.textContent=t; if (ratio!=null) resetProgressFill.style.width=`${Math.max(1,Math.min(100,ratio*100))}%`; }

            try{
                resetBtn.disabled=true; resetProgress.classList.add('show');
                resetStatus.className='status info'; resetStatus.style.display='block'; resetStatus.textContent='‚è≥ Ejecutando reset total...';

                const collections = ['calendar_events','shifts','users','shift_templates','local_users','families','alarms','dayCategories','notes'];
                const total = collections.length; let done=0;
                for (const name of collections){
                    setProgress(`Eliminando colecci√≥n: ${name}`, (done/total)*0.9);
                    try{
                        const snap = await db.collection(name).get();
                        if (!snap.empty){
                            const batchSize = 400; // en lotes por l√≠mites de Firestore
                            let idx=0;
                            while (idx < snap.size){
                                const batch = db.batch();
                                snap.docs.slice(idx, idx+batchSize).forEach(doc => batch.delete(doc.ref));
                                await batch.commit();
                                idx += batchSize;
                            }
                        }
                    }catch(e){ /* colecci√≥n puede no existir */ }
                    done++;
                }

                // Semilla m√≠nima (opcional)
                if (seed){
                    setProgress('Sembrando turnos por defecto...', 0.95);
                    const defaults = [
                        { name:'D1', abbreviation:'D1', backgroundColor:'#2196F3', textColor:'#FFFFFF', timeSlots:[{startTime:'08:00', endTime:'20:00'}] },
                        { name:'D2', abbreviation:'D2', backgroundColor:'#F44336', textColor:'#FFFFFF', timeSlots:[{startTime:'20:00', endTime:'08:00'}] },
                        { name:'Libre', abbreviation:'L', backgroundColor:'#4CAF50', textColor:'#FFFFFF' },
                        { name:'Oper', abbreviation:'Oper', backgroundColor:'#FBC02D', textColor:'#000000' }
                    ];
                    for (const s of defaults){ await db.collection('shifts').add(s); }
                }

                setProgress('Listo', 1);
                resetStatus.className='status success'; resetStatus.textContent='‚úÖ Reset completado.';
            }catch(e){
                console.error('resetDatabase',e);
                resetStatus.className='status error'; resetStatus.textContent=`‚ùå Error en reset: ${e.message}`;
            }finally{
                resetBtn.disabled=false;
                setTimeout(()=>resetProgress.classList.remove('show'), 2000);
            }
        }
    </script>
</body>
</html>


