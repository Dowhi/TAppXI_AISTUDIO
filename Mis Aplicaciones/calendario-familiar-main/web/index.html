<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- Meta tags iOS para modo standalone -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FamilySync">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1B5E20">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-touch-startup-image" content="icons/Icon-512.png">

    <title>Calendario - FamilySync</title>

    <!-- Manifest para PWA -->
    <link rel="manifest" href="manifest.json">

    <!-- Iconos iOS -->
    <link rel="apple-touch-icon" href="icons/Icon-192.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icons/Icon-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="icons/Icon-512.png">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
        }

        html,
        body {
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        body {
            background: #f5f5f5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: #1B5E20;
            color: white;
            padding: 4px 12px;
            padding-top: max(4px, calc(env(safe-area-inset-top) + 4px));
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            min-height: 36px;
        }

        .header-title {
            font-size: 14px;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .header-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 6px;
            padding: 4px 8px;
            color: white;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .header-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .menu-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 6px;
            padding: 4px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
        }

        .menu-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Tab Navigation */
        .tab-nav {
            background: #1976D2;
            display: flex;
            flex-shrink: 0;
            min-height: 32px;
        }

        .tab-btn {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            padding: 6px 4px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            text-transform: uppercase;
        }

        .tab-btn.active {
            background: rgba(255, 255, 255, 0.2);
        }

        .tab-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Month Navigation */
        .month-nav {
            background: #2196F3;
            padding: 4px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            min-height: 28px;
        }

        .month-nav button {
            background: transparent;
            border: none;
            padding: 0;
            width: 28px;
            height: 28px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .month-nav button:active {
            opacity: 0.7;
        }

        .month-title {
            font-size: 12px;
            font-weight: 600;
            color: white;
        }

        /* Settings Modal */
        .settings-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: flex-end;
            justify-content: center;
            z-index: 3000;
        }

        .settings-backdrop.show {
            display: flex;
        }

        .settings-panel {
            background: #ffffff;
            width: 100%;
            max-width: 520px;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
            box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.2);
            padding: 16px;
            padding-top: max(48px, calc(env(safe-area-inset-top) + 48px));
        }

        .settings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .settings-title {
            font-size: 16px;
            font-weight: 700;
        }

        .settings-group {
            margin: 12px 0;
            padding: 12px;
            background: #f7f7f7;
            border-radius: 12px;
        }

        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 8px 0;
        }

        .settings-row+.settings-row {
            border-top: 1px solid #eaeaea;
        }

        .settings-label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .settings-select,
        .settings-checkbox {
            margin-left: auto;
        }

        .settings-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        /* Theme Selector */
        .theme-selector {
            display: flex;
            gap: 8px;
            background: #e9e9e9;
            padding: 4px;
            border-radius: 12px;
            position: relative;
        }

        .theme-option {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 12px 8px;
            border: none;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 2;
        }

        .theme-option:hover {
            transform: translateY(-2px);
        }

        .theme-option.active {
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .theme-icon {
            font-size: 24px;
            line-height: 1;
            display: block;
        }

        .theme-name {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            transition: color 0.3s;
        }

        .theme-option.active .theme-name {
            color: #2196F3;
        }

        /* Dark mode styles */
        body.dark-theme {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        body.dark-theme .header {
            background: #0D47A1;
            border-bottom: 1px solid #0a3470;
        }

        body.dark-theme .tab-nav {
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
        }

        body.dark-theme .tab-btn {
            color: #b0b0b0;
            background: transparent;
        }

        body.dark-theme .tab-btn.active {
            color: #fff;
            background: #3a3a3a;
        }

        body.dark-theme .month-nav {
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
        }

        body.dark-theme .calendar-day {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
        }

        body.dark-theme .calendar-day.other-month {
            background: #1f1f1f;
            opacity: 0.5;
        }

        body.dark-theme .calendar-day.today {
            border: 2px solid #ff4444;
        }

        body.dark-theme .weekday-header {
            background: #333;
            color: #b0b0b0;
        }

        body.dark-theme .settings-backdrop {
            background: rgba(0, 0, 0, 0.7);
        }

        body.dark-theme .settings-panel {
            background: #2a2a2a;
            color: #e0e0e0;
        }

        body.dark-theme .settings-group {
            background: #1f1f1f;
        }

        body.dark-theme .settings-label {
            color: #b0b0b0;
        }

        body.dark-theme .btn-secondary {
            background: #3a3a3a;
            color: #e0e0e0;
        }

        body.dark-theme .btn-secondary:hover {
            background: #4a4a4a;
        }

        body.dark-theme .theme-selector {
            background: #1f1f1f;
        }

        body.dark-theme .theme-option.active {
            background: #3a3a3a;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        body.dark-theme .theme-name {
            color: #aaa;
        }

        body.dark-theme .theme-option.active .theme-name {
            color: #4da3ff;
        }

        /* Dark mode for modals */
        body.dark-theme .modal-backdrop,
        body.dark-theme .day-modal {
            background: rgba(0, 0, 0, 0.8);
        }

        body.dark-theme .modal-content,
        body.dark-theme .day-modal-content {
            background: #2a2a2a;
            color: #e0e0e0;
        }

        body.dark-theme .modal-header,
        body.dark-theme .day-modal-header {
            background: #0D47A1;
            border-bottom: 1px solid #0a3470;
        }

        body.dark-theme .modal-body,
        body.dark-theme .day-modal-body {
            background: #2a2a2a;
        }

        body.dark-theme .notes-modal {
            background: rgba(0, 0, 0, 0.8);
        }

        body.dark-theme .notes-modal-content {
            background: #2a2a2a;
        }

        body.dark-theme .notes-header {
            background: #ff5722;
        }

        body.dark-theme .notes-content-editable {
            background: #1f1f1f;
            color: #e0e0e0;
            border: 1px solid #3a3a3a;
        }

        body.dark-theme .notes-time-input,
        body.dark-theme .notes-text-size-slider {
            background: #1f1f1f;
            color: #e0e0e0;
            border: 1px solid #3a3a3a;
        }

        body.dark-theme .format-btn {
            background: #1f1f1f;
            border-color: #3a3a3a;
            color: #e0e0e0;
        }

        body.dark-theme .format-btn.active {
            background: #00BCD4;
            border-color: #00BCD4;
            color: white;
        }

        body.dark-theme .notes-visibility-container,
        body.dark-theme .notes-time-container,
        body.dark-theme .notes-text-size-container {
            background: #2a2a2a;
        }

        body.dark-theme .user-checkbox-item {
            color: #b0b0b0;
        }

        body.dark-theme .notes-accept-btn {
            background: #43a047;
        }

        body.dark-theme .notes-cancel-btn {
            background: #ef5350;
        }

        body.dark-theme .notes-delete-btn {
            background: #d32f2f;
        }

        @media (prefers-color-scheme: dark) {
            body:not(.light-theme) {
                background: #1a1a1a;
                color: #e0e0e0;
            }

            body:not(.light-theme) .header {
                background: #0D47A1;
            }

            body:not(.light-theme) .calendar-day {
                background: #2a2a2a;
                border: 1px solid #3a3a3a;
            }

            body:not(.light-theme) .theme-selector {
                background: #1f1f1f;
            }

            body:not(.light-theme) .theme-option.active {
                background: #3a3a3a;
            }
        }

        /* Theme transition animation */
        .theme-transition {
            animation: themeSwitch 0.5s ease-in-out;
        }

        @keyframes themeSwitch {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
                transform: scale(0.98);
            }
        }

        .btn {
            border: none;
            padding: 10px 12px;
            border-radius: 10px;
            font-weight: 700;
            cursor: pointer;
        }

        .btn-primary {
            background: #2a7ade;
            color: #fff;
        }

        .btn-secondary {
            background: #e9e9e9;
            color: #333;
        }

        /* Calendar */
        .calendar-container {
            flex: 1;
            overflow: hidden;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            /* grid-template-rows se establece dinámicamente en JS según 5 o 6 semanas */
            gap: 0;
            margin-bottom: 0;
            flex: 1;
            height: 100%;
        }

        .weekday-header {
            text-align: center;
            padding: 1px 2px;
            font-size: 9px;
            font-weight: 600;
            color: #666;
            height: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
            border: 1px solid #ddd;
            line-height: 1;
        }

        .calendar-day {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1px;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: all 0.2s;
            overflow: hidden;
            /* Sin altura fija, usar flex */
            position: relative;
        }

        .calendar-day:active {
            transform: scale(0.95);
            background: #f9f9f9;
        }

        .calendar-day.other-month {
            opacity: 0.3;
            background: #f9f9f9;
        }

        .calendar-day.today {
            border: 2px solid #1B5E20;
            background: #f1f8e9;
        }

        /* Estilo específico para el número del día de hoy */
        .calendar-day.today .day-number {
            background: #FF1744;
            /* rojo fluorescente */
            color: #ffffff !important;
            border-radius: 50%;
            padding: 2px 6px;
        }

        .day-number {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 11px;
            font-weight: 600;
            line-height: 1;
            color: #333;
        }

        /* Iconos de categorías en las celdas */
        .category-icons {
            position: absolute;
            bottom: 2px;
            left: 2px;
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
            max-width: calc(100% - 20px);
        }

        .category-icon {
            font-size: 8px;
            line-height: 1;
            opacity: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 2px;
            padding: 1px 2px;
            border: 1px solid;
            font-weight: 600;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Year view */
        .year-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #2e7d32;
            color: white;
            flex-shrink: 0;
        }

        .year-nav .title {
            font-weight: 700;
        }

        .year-nav button {
            width: 40px;
            height: 28px;
            color: white;
            background: rgba(255, 255, 255, 0.15);
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .year-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 8px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            -webkit-overflow-scrolling: touch;
        }

        /* Vista anual permitir scroll */
        #yearView {
            overflow: hidden !important;
        }

        #yearView .year-grid {
            overflow-y: auto;
            min-height: 0;
            max-height: calc(100vh - 152px);
        }

        .year-month {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }

        .year-month-header {
            background: #2196F3;
            color: #fff;
            text-align: center;
            font-weight: 700;
            font-size: 12px;
            padding: 6px 0;
        }

        .year-month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }

        .year-weekday {
            text-align: center;
            font-size: 10px;
            color: #666;
            padding: 3px 0;
            background: #eaeaea;
            border-bottom: 1px solid #ddd;
        }

        .year-day {
            position: relative;
            height: 22px;
            border-right: 1px solid #eee;
            border-bottom: 1px solid #eee;
            background: #fff;
            border-radius: 4px;
        }

        .year-day.other-month {
            background: #fafafa;
        }

        .year-day-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 10px;
            color: #333;
            z-index: 2;
        }

        /* (Revertido) estilos de vista anual eliminados */

        .day-events {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 1px;
            margin-top: 16px;
            padding: 2px;
        }

        .event-badge {
            font-size: 9px;
            /* Un poco más grande para leerse mejor */
            padding: 2px 3px;
            border-radius: 2px;
            background: #e3f2fd;
            color: #1976d2;

            /* Permitir 2 líneas */
            white-space: normal;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;

            line-height: 1.2;
            max-height: 2.4em;
            /* aprox 2 líneas */
        }

        .event-dot {
            width: 6px;
            height: 6px;
            border-radius: 3px;
            background: #1976d2;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: flex-start;
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
        }

        .modal.show {
            display: flex;
        }

        /* Estilos para el modal - Réplica exacta de las fotos */
        .modal-content-exact {
            background: white;
            width: 100%;
            max-width: 500px;
            min-height: 100vh;
            border-radius: 0;
            overflow: hidden;
            box-shadow: none;
            margin: 0 auto;
            padding: 0;
        }

        /* Top Blue Header */
        .modal-header-blue {
            background: #2196F3;
            color: white;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .back-arrow {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-date {
            font-size: 18px;
            font-weight: bold;
            flex: 1;
            text-align: center;
        }

        .header-spacer {
            width: 30px;
        }

        /* Main Content Card */
        .main-content-card {
            background: white;
            margin: 0;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .document-icon {
            font-size: 20px;
            color: #666;
            margin-top: 4px;
        }

        .main-textarea {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 12px;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            min-height: 80px;
            outline: none;
        }

        .main-textarea::placeholder {
            color: #999;
        }

        /* Alarm Section */
        .alarm-section {
            background: white;
            margin: 0;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .alarm-section:active {
            background-color: #f5f5f5;
        }

        .alarm-icon {
            font-size: 24px;
            color: #f44336;
        }

        .alarm-text {
            flex: 1;
            font-size: 16px;
            font-weight: bold;
            color: #f44336;
        }

        .alarm-number {
            background: #FF9800;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }

        /* Modal de configuración de alarma */
        .alarm-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .alarm-modal.show {
            display: flex;
        }

        .alarm-modal-content {
            background: white;
            width: 100%;
            max-width: 400px;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .alarm-modal-header {
            background: #FF9800;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 16px 16px 0 0;
        }

        .alarm-modal-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .alarm-modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .alarm-modal-body {
            padding: 20px;
        }

        .alarm-input-group {
            margin-bottom: 20px;
        }

        .alarm-input-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
        }

        .alarm-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            outline: none;
        }

        .alarm-input:focus {
            border-color: #FF9800;
        }

        .alarm-list {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .alarm-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .alarm-item:last-child {
            border-bottom: none;
        }

        .alarm-item-info {
            flex: 1;
        }

        .alarm-item-date {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .alarm-item-time {
            color: #666;
            font-size: 12px;
            margin-top: 4px;
        }

        .alarm-item-delete {
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
        }

        /* Day Shifts Section */
        .shifts-card {
            background: white;
            margin: 0;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
            border-bottom: 1px solid #f0f0f0;
        }

        .shifts-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 16px;
        }

        .shifts-content {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
            width: 100%;
        }

        .clock-icon {
            font-size: 48px;
            color: #ccc;
        }

        .no-shifts-text {
            color: #999;
            font-size: 14px;
        }

        /* Shift Display Styles */
        .shift-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: #E8F5E8;
            border: 1px solid #4CAF50;
            border-radius: 6px;
            margin: 4px 0;
            width: 100%;
            box-sizing: border-box;
        }

        .shift-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4CAF50;
        }

        .shift-name {
            font-size: 14px;
            color: #2E7D32;
            font-weight: 500;
        }

        /* Categories Section */
        .categories-card {
            background: white;
            margin: 0;
            padding: 20px;
            border-radius: 0;
            box-shadow: none;
            border-bottom: 1px solid #f0f0f0;
        }

        .categories-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 16px;
        }

        .categories-dropdowns {
            display: flex;
            gap: 8px;
            width: 100%;
        }

        .category-dropdown {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            min-width: 0;
            position: relative;
        }

        .no-icon {
            font-size: 12px;
            color: #999;
        }

        .dropdown-text {
            flex: 1;
            font-size: 11px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dropdown-arrow {
            font-size: 10px;
            color: #999;
        }

        /* Dropdown Options */
        .dropdown-options {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            max-height: none;
            overflow-y: visible;
            display: none;
            min-width: 120px;
            margin-bottom: 4px;
        }

        .dropdown-options.show {
            display: block;
        }

        .dropdown-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 14px;
            /* Aumentado para mejor tacto */
            cursor: pointer;
            font-size: 14px;
            /* Aumentado */
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
            min-height: 44px;
            /* Altura mínima recomendada para touch */
        }

        .dropdown-option:hover {
            background-color: #f5f5f5;
        }

        .dropdown-option:last-child {
            border-bottom: none;
        }

        .dropdown-option-icon {
            font-size: 16px;
            /* Aumentado */
            width: 20px;
            text-align: center;
        }

        .dropdown-option-text {
            font-size: 13px;
            /* Aumentado */
            color: #333;
            white-space: nowrap;
        }

        /* Action Buttons */
        .action-buttons {
            background: #f5f5f5;
            padding: 20px;
            display: flex;
            gap: 12px;
            margin-top: auto;
        }

        .btn-cancel,
        .btn-accept {
            flex: 1;
            padding: 14px 20px;
            border: 2px solid;
            border-radius: 4px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-cancel {
            background: white;
            border-color: #f44336;
            color: #f44336;
        }

        .btn-cancel:hover {
            background: #f44336;
            color: white;
        }

        .btn-accept {
            background: white;
            border-color: #4CAF50;
            color: #4CAF50;
        }

        .btn-accept:hover {
            background: #4CAF50;
            color: white;
        }

        /* Media queries para pantallas pequeñas */
        @media (max-width: 480px) {
            .modal-content-exact {
                max-width: 100%;
                margin: 0;
            }

            .categories-dropdowns {
                gap: 4px;
            }

            .category-dropdown {
                padding: 6px 4px;
                gap: 2px;
            }

            .dropdown-text {
                font-size: 10px;
            }

            .no-icon {
                font-size: 10px;
            }

            .dropdown-arrow {
                font-size: 8px;
            }
        }

        /* Modal de Notas - Réplica exacta de la imagen */
        .notes-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .notes-modal:not(.show) {
            pointer-events: none;
        }

        .notes-modal.show {
            display: flex;
        }

        .notes-modal-content {
            background: white;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
        }

        /* Contenedor scrollable para el contenido */
        .notes-modal-scrollable {
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Cerrar modal al hacer clic fuera */
        .notes-modal.show .notes-modal-content {
            pointer-events: auto;
        }

        .notes-modal.show::before {
            content: '';
            position: absolute;
            inset: 0;
            z-index: 0;
        }

        /* Header rojo */
        .notes-header {
            background: #f44336;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 16px 16px 0 0;
        }

        .notes-title {
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .notes-share-icon {
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        /* Campo de texto */
        .notes-input-container {
            padding: 20px;
            background: white;
            flex-shrink: 0;
        }

        .notes-textarea {
            width: 100%;
            min-height: 150px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            font-size: 16px;
            font-family: inherit;
            resize: none;
            outline: none;
            background: white;
        }

        /* Div editable para formato de texto */
        .notes-content-editable {
            width: 100%;
            min-height: 150px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            font-size: 16px;
            font-family: inherit;
            outline: none;
            background: white;
            overflow-y: auto;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .notes-content-editable:empty:before {
            content: attr(data-placeholder);
            color: #999;
        }

        .notes-content-editable:focus {
            border-color: #2196F3;
        }

        /* Control de tamaño de texto */
        .notes-text-size-container {
            padding: 0 20px 12px;
            background: white;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .notes-text-size-label {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .notes-text-size-control {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .notes-text-size-value {
            font-size: 14px;
            font-weight: bold;
            color: #333;
            min-width: 30px;
            text-align: center;
        }

        .notes-text-size-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .notes-text-size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00BCD4;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .notes-text-size-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #00BCD4;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Campo de Hora */
        .notes-time-container {
            padding: 0 20px 12px;
            background: white;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .notes-time-label {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .notes-time-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            background: white;
        }

        .notes-time-input:focus {
            outline: none;
            border-color: #00BCD4;
            box-shadow: 0 0 0 2px rgba(0, 188, 212, 0.1);
        }

        /* Selector de visibilidad */
        .notes-visibility-container {
            padding: 0 20px 12px;
            background: white;
            flex-shrink: 0;
        }

        .notes-visibility-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 6px;
        }

        .notes-visibility-options {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .notes-private-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
        }

        .notes-visibility-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .notes-user-selection {
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid #e0e0e0;
        }

        .user-checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 13px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
        }

        .user-checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .user-checkbox-item .user-color-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: inline-block;
        }

        /* Botones de formato */
        .notes-format-buttons {
            display: flex;
            gap: 12px;
            padding: 0 20px 12px;
            justify-content: center;
            flex-shrink: 0;
        }

        .format-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 1px solid #00BCD4;
            background: white;
            color: #333;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .format-btn.active {
            background: #00BCD4;
            color: white;
            border-color: #00BCD4;
        }

        .format-btn:active {
            transform: scale(0.95);
        }

        /* Botones de acción */
        .notes-action-buttons {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex-shrink: 0;
            background: white;
            border-top: 1px solid #f0f0f0;
        }

        .action-buttons-row {
            display: flex;
            gap: 12px;
        }

        .action-btn {
            padding: 12px 20px;
            border: 2px solid;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            flex: 1;
        }

        .delete-btn {
            background: white;
            border: 2px solid #333;
            color: #333;
            width: 100%;
            display: block;
            font-weight: bold;
        }

        .delete-btn:hover {
            background: #f5f5f5;
        }

        .delete-btn:active {
            background: #333;
            color: white;
        }

        .cancel-btn {
            background: white;
            border: 2px solid #f44336;
            color: #f44336;
            display: block;
            min-width: 100px;
            font-weight: bold;
        }

        .cancel-btn:hover {
            background: #f44336;
            color: white;
        }

        .cancel-btn:active {
            background: #d32f2f;
            border-color: #d32f2f;
            color: white;
        }

        .accept-btn {
            background: white;
            border: 2px solid #4CAF50;
            color: #4CAF50;
            display: block;
            min-width: 100px;
            font-weight: bold;
        }

        .accept-btn:hover {
            background: #4CAF50;
            color: white;
        }

        .accept-btn:active {
            background: #388E3C;
            border-color: #388E3C;
            color: white;
        }

        .action-buttons-row {
            display: flex;
            gap: 12px;
            width: 100%;
        }

        .action-buttons-row .action-btn {
            flex: 1;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            padding: 24px;
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1B5E20;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
        }

        .modal-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #666;
        }

        .event-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .event-item {
            padding: 12px;
            background: #f5f5f5;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .event-text {
            flex: 1;
            font-size: 14px;
        }

        .event-user {
            font-size: 10px;
            color: #666;
            margin-top: 4px;
        }

        .delete-btn {
            background: #f44336;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            color: white;
            font-size: 12px;
            cursor: pointer;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-field {
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
        }

        .btn-primary {
            background: #1B5E20;
            border: none;
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-primary:active {
            background: #2E7D32;
        }

        .empty-message {
            text-align: center;
            color: #999;
            font-style: italic;
            padding: 20px;
        }

        /* Bottom Info */
        .bottom-info {
            background: white;
            padding: 3px 12px;
            text-align: center;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
            min-height: 20px;
        }

        .current-user-info {
            font-size: 9px;
            color: #666;
        }

        /* Bottom Action Buttons */
        .bottom-actions {
            background: white;
            padding: 0;
            display: flex !important;
            gap: 0;
            flex-shrink: 0;
            min-height: 40px;
            position: relative;
            z-index: 2000 !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .action-btn {
            flex: 1;
            border: none;
            border-radius: 0;
            padding: 10px 6px;
            color: white;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .action-btn:active {
            opacity: 0.8;
            transform: scale(0.98);
        }

        .action-btn.pintar {
            background: #FF9800;
        }

        .action-btn.editar {
            background: #2196F3;
        }

        .action-btn.turnos {
            background: #4CAF50;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
            display: none !important;
        }

        .connection-status.connected {
            background: #4CAF50;
            color: white;
        }

        .connection-status.disconnected {
            background: #FF9800;
            color: white;
        }

        .connection-status.error {
            background: #F44336;
            color: white;
        }

        /* Pop-up de Selección de Turnos */
        .shifts-popup {
            position: fixed;
            bottom: 0 !important;
            left: 0;
            right: 0;
            background: white;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
            z-index: 1900 !important;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            display: none !important;
            flex-direction: row;
            align-items: center;
            padding: 4px 8px;
            min-height: 52px;
        }

        .shifts-popup.show {
            display: flex !important;
            transform: translateY(0);
            z-index: 2100 !important;
        }

        /* Ocultar barra de botones cuando el pop-up está abierto */
        .shifts-popup.show~.bottom-actions {
            display: none !important;
        }

        .shifts-popup-header {
            display: none;
        }

        .shifts-popup-close {
            background: none;
            border: none;
            font-size: 18px;
            color: #666;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .shifts-popup-close:active {
            background: #f0f0f0;
        }

        .shifts-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            flex-direction: row;
            gap: 8px;
            flex-wrap: nowrap;
            flex: 1;
            white-space: nowrap;
            padding: 0;
        }

        .shift-button-paint {
            min-width: 40px;
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            color: white;
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        .shift-button-paint:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .shift-button-paint:hover {
            opacity: 0.9;
        }

        /* Color por defecto para turnos sin color especificado */
        .shift-button-paint.default {
            background: #9E9E9E;
        }

        /* Botón de borrar turnos */
        .shift-button-delete {
            min-width: 40px;
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: 50%;
            border: 2px solid #f44336;
            cursor: pointer;
            font-size: 20px;
            font-weight: normal;
            color: #f44336;
            background: white;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .shift-button-delete:active {
            transform: scale(0.95);
            background: #f44336;
            color: white;
        }

        .shift-button-delete:hover {
            background: #f44336;
            color: white;
        }
    </style>
</head>

<body>


    <!-- Header -->
    <div class="header">
        <div class="header-title">My Calendar</div>
        <div class="header-actions">
            <button class="header-btn" onclick="openUserSelector()">👤</button>
            <button class="menu-btn" onclick="openSettings()">⚙️</button>
        </div>
    </div>

    <!-- Tab Navigation -->
    <div class="tab-nav">
        <button class="tab-btn active" onclick="showTab('calendar')">Calendario</button>
        <button class="tab-btn" onclick="showTab('year')"><span id="currentYearDisplay"></span></button>
        <button class="tab-btn" onclick="showTab('summary')">Resumen</button>
    </div>

    <!-- Month Navigation -->
    <div class="month-nav">
        <button onclick="changeMonth(-1)">‹</button>
        <div class="month-title" id="monthTitle"></div>
        <button onclick="changeMonth(1)">›</button>
    </div>

    <!-- Calendar -->
    <div class="calendar-container">
        <div class="calendar-grid" id="calendarGrid">
            <!-- Se carga dinámicamente -->
        </div>
    </div>

    <!-- Year View (anual) -->
    <div class="calendar-container" id="yearView" style="display: none;">
        <div class="year-nav">
            <button onclick="changeYear(-1)">‹</button>
            <div class="title" id="yearTitle">2025</div>
            <button onclick="changeYear(1)">›</button>
        </div>
        <div class="year-grid" id="yearGrid"></div>
    </div>



    <!-- Bottom Info -->
    <div class="bottom-info" style="display: none;">
        <div class="current-user-info" id="currentUserInfo"></div>
    </div>

    <!-- Bottom Action Buttons -->
    <div class="bottom-actions">
        <button class="action-btn pintar" onclick="activatePaintMode()">PINTAR</button>
        <button class="action-btn editar" onclick="activateEditMode()">EDITAR</button>
        <button class="action-btn turnos" onclick="showShifts()">TURNOS</button>
    </div>

    <!-- Settings Modal -->
    <div class="settings-backdrop" id="settingsModal">
        <div class="settings-panel" onclick="event.stopPropagation()">
            <div class="settings-header">
                <div class="settings-title">Configuración</div>
                <button class="btn btn-secondary" onclick="closeSettings()">Cerrar</button>
            </div>
            <div class="settings-group">
                <div class="settings-row">
                    <div class="settings-label">Tema</div>
                    <div class="theme-selector">
                        <button class="theme-option" data-theme="light" onclick="selectTheme('light')">
                            <span class="theme-icon">☀️</span>
                            <span class="theme-name">Claro</span>
                        </button>
                        <button class="theme-option" data-theme="system" onclick="selectTheme('system')">
                            <span class="theme-icon">🖥️</span>
                            <span class="theme-name">Auto</span>
                        </button>
                        <button class="theme-option" data-theme="dark" onclick="selectTheme('dark')">
                            <span class="theme-icon">🌙</span>
                            <span class="theme-name">Oscuro</span>
                        </button>
                    </div>
                    <select id="stTheme" class="settings-select" style="display: none;">
                        <option value="system">Sistema</option>
                        <option value="light">Claro</option>
                        <option value="dark">Oscuro</option>
                    </select>
                </div>
                <div class="settings-row">
                    <div class="settings-label">Inicio de semana</div>
                    <select id="stWeekStart" class="settings-select">
                        <option value="monday">Lunes</option>
                        <option value="sunday">Domingo</option>
                    </select>
                </div>
                <div class="settings-row">
                    <div class="settings-label">Resaltar día de hoy en rojo</div>
                    <input id="stHighlightToday" type="checkbox" class="settings-checkbox" />
                </div>
                <div class="settings-row">
                    <div class="settings-label">Sexta semana solo si es necesaria</div>
                    <input id="stSmartWeeks" type="checkbox" class="settings-checkbox" />
                </div>
            </div>
            <div class="settings-group">
                <div class="settings-row">
                    <div class="settings-label">📅 Vista Semanal</div>
                    <button class="btn btn-secondary" onclick="window.location.href='week-view.html'">Ir</button>
                </div>
                <div class="settings-row">
                    <div class="settings-label">🔔 Recordatorios</div>
                    <button class="btn btn-secondary" onclick="window.location.href='reminders.html'">Ir</button>
                </div>
                <div class="settings-row">
                    <div class="settings-label">🔄 Eventos Recurrentes</div>
                    <button class="btn btn-secondary" onclick="window.location.href='recurring-events.html'">Ir</button>
                </div>
                <div class="settings-row">
                    <div class="settings-label">📤 Exportar Calendario</div>
                    <button class="btn btn-secondary" onclick="window.location.href='export-calendar.html'">Ir</button>
                </div>
                <div class="settings-row">
                    <div class="settings-label">Copias de seguridad</div>
                    <div class="settings-actions">
                        <button class="btn btn-secondary"
                            onclick="window.location.href='firestore_backup.html'">Backup</button>
                        <button class="btn btn-secondary"
                            onclick="window.location.href='firestore_cleanup.html'">Herramientas</button>
                    </div>
                </div>
            </div>
            <div class="settings-actions">
                <button class="btn btn-primary" onclick="saveSettings()">Guardar</button>
                <button class="btn btn-secondary" onclick="resetSettings()">Restablecer</button>
            </div>
        </div>
    </div>

    <!-- Pop-up de Selección de Turnos para Pintar -->
    <div class="shifts-popup" id="shiftsPopup" hidden>
        <button class="shifts-popup-close" onclick="closeShiftsPopup()">⌄</button>
        <div class="shifts-scroll" id="shiftsScroll">
            <!-- Se carga dinámicamente -->
        </div>
    </div>

    <!-- Modal for Day Details - Réplica exacta de las fotos -->
    <div class="modal" id="dayModal">
        <div class="modal-content-exact">
            <!-- Top Blue Header -->
            <div class="modal-header-blue">
                <div class="header-date" id="modalDate">8/10/25</div>
            </div>

            <!-- Main Content Card -->
            <div class="main-content-card">
                <div class="document-icon">📄+</div>
                <textarea class="main-textarea" placeholder="Añadir nota..." id="mainTextarea"
                    onclick="openNotesPopup()" style="cursor: pointer;"></textarea>
            </div>

            <!-- Alarm Section -->
            <div class="alarm-section" onclick="openAlarmModal()">
                <div class="alarm-icon">🔔</div>
                <div class="alarm-text">Aviso de Alarma</div>
                <div class="alarm-number" id="alarmNumber">0</div>
            </div>

            <!-- Day Shifts Section -->
            <div class="shifts-card">
                <div class="shifts-title">Turnos del día</div>
                <div class="shifts-content" id="shiftsContent">
                    <div class="clock-icon">🕐</div>
                    <div class="no-shifts-text">No hay turnos asignados</div>
                </div>
            </div>

            <!-- Categories Section -->
            <div class="categories-card">
                <div class="categories-title">Categorías</div>
                <div class="categories-dropdowns">
                    <div class="category-dropdown" onclick="toggleDropdown(0)">
                        <div class="no-icon">🚫</div>
                        <span class="dropdown-text">Ninguno</span>
                        <span class="dropdown-arrow">▼</span>
                        <div class="dropdown-options" id="dropdown-0">
                            <div class="dropdown-option" onclick="selectCategory(0, 'Ninguno', '')">
                                <div class="dropdown-option-icon"></div>
                                <div class="dropdown-option-text">Ninguno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Cambio de turno', '🔀')">
                                <div class="dropdown-option-icon">🔀</div>
                                <div class="dropdown-option-text">Cambio de turno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Pago', '💳')">
                                <div class="dropdown-option-icon">💳</div>
                                <div class="dropdown-option-text">Pago</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Importante', '🔔')">
                                <div class="dropdown-option-icon">🔔</div>
                                <div class="dropdown-option-text">Importante</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Festivo', '🎉')">
                                <div class="dropdown-option-icon">🎉</div>
                                <div class="dropdown-option-text">Festivo</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Médico', '💊')">
                                <div class="dropdown-option-icon">💊</div>
                                <div class="dropdown-option-text">Médico</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Cumpleaños', '🎂')">
                                <div class="dropdown-option-icon">🎂</div>
                                <div class="dropdown-option-text">Cumpleaños</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Favorito', '🔖')">
                                <div class="dropdown-option-icon">🔖</div>
                                <div class="dropdown-option-text">Favorito</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(0, 'Coche', '🚙')">
                                <div class="dropdown-option-icon">🚙</div>
                                <div class="dropdown-option-text">Coche</div>
                            </div>
                        </div>
                    </div>
                    <div class="category-dropdown" onclick="toggleDropdown(1)">
                        <div class="no-icon">🚫</div>
                        <span class="dropdown-text">Ninguno</span>
                        <span class="dropdown-arrow">▼</span>
                        <div class="dropdown-options" id="dropdown-1">
                            <div class="dropdown-option" onclick="selectCategory(1, 'Ninguno', '')">
                                <div class="dropdown-option-icon"></div>
                                <div class="dropdown-option-text">Ninguno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Cambio de turno', '🔀')">
                                <div class="dropdown-option-icon">🔀</div>
                                <div class="dropdown-option-text">Cambio de turno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Pago', '💳')">
                                <div class="dropdown-option-icon">💳</div>
                                <div class="dropdown-option-text">Pago</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Importante', '🔔')">
                                <div class="dropdown-option-icon">🔔</div>
                                <div class="dropdown-option-text">Importante</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Festivo', '🎉')">
                                <div class="dropdown-option-icon">🎉</div>
                                <div class="dropdown-option-text">Festivo</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Médico', '💊')">
                                <div class="dropdown-option-icon">💊</div>
                                <div class="dropdown-option-text">Médico</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Cumpleaños', '🎂')">
                                <div class="dropdown-option-icon">🎂</div>
                                <div class="dropdown-option-text">Cumpleaños</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Favorito', '🔖')">
                                <div class="dropdown-option-icon">🔖</div>
                                <div class="dropdown-option-text">Favorito</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(1, 'Coche', '🚙')">
                                <div class="dropdown-option-icon">🚙</div>
                                <div class="dropdown-option-text">Coche</div>
                            </div>
                        </div>
                    </div>
                    <div class="category-dropdown" onclick="toggleDropdown(2)">
                        <div class="no-icon">🚫</div>
                        <span class="dropdown-text">Ninguno</span>
                        <span class="dropdown-arrow">▼</span>
                        <div class="dropdown-options" id="dropdown-2">
                            <div class="dropdown-option" onclick="selectCategory(2, 'Ninguno', '')">
                                <div class="dropdown-option-icon"></div>
                                <div class="dropdown-option-text">Ninguno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Cambio de turno', '🔀')">
                                <div class="dropdown-option-icon">🔀</div>
                                <div class="dropdown-option-text">Cambio de turno</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Pago', '💳')">
                                <div class="dropdown-option-icon">💳</div>
                                <div class="dropdown-option-text">Pago</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Importante', '🔔')">
                                <div class="dropdown-option-icon">🔔</div>
                                <div class="dropdown-option-text">Importante</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Festivo', '🎉')">
                                <div class="dropdown-option-icon">🎉</div>
                                <div class="dropdown-option-text">Festivo</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Médico', '💊')">
                                <div class="dropdown-option-icon">💊</div>
                                <div class="dropdown-option-text">Médico</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Cumpleaños', '🎂')">
                                <div class="dropdown-option-icon">🎂</div>
                                <div class="dropdown-option-text">Cumpleaños</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Favorito', '🔖')">
                                <div class="dropdown-option-icon">🔖</div>
                                <div class="dropdown-option-text">Favorito</div>
                            </div>
                            <div class="dropdown-option" onclick="selectCategory(2, 'Coche', '🚙')">
                                <div class="dropdown-option-icon">🚙</div>
                                <div class="dropdown-option-text">Coche</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="btn-cancel" onclick="closeModal()">CANCELAR</button>
                <button class="btn-accept" onclick="acceptDayChanges()">ACEPTAR</button>
            </div>
        </div>
    </div>

    <!-- Modal de Notas - Réplica exacta de la imagen -->
    <div class="notes-modal" id="notesModal" onclick="handleNotesModalClick(event)">
        <div class="notes-modal-content" onclick="event.stopPropagation()">
            <!-- Header rojo -->
            <div class="notes-header">
                <div class="notes-title">NOTAS</div>
                <div class="notes-share-icon">🔗</div>
            </div>

            <!-- Campo de texto -->
            <div class="notes-input-container">
                <div class="notes-content-editable" id="notesTextarea" contenteditable="true"
                    data-placeholder="Notas del día..."></div>
            </div>

            <!-- Botones de formato -->
            <div class="notes-format-buttons">
                <button class="format-btn" id="formatBold" onclick="toggleFormat('bold')">B</button>
                <button class="format-btn" id="formatItalic" onclick="toggleFormat('italic')">I</button>
                <button class="format-btn" id="formatUnderline" onclick="toggleFormat('underline')">U</button>
            </div>

            <!-- Control de tamaño de texto -->
            <div class="notes-text-size-container">
                <label class="notes-text-size-label">Tamaño del texto en celdas:</label>
                <div class="notes-text-size-control">
                    <span class="notes-text-size-value" id="notesTextSizeValue">11</span>
                    <input type="range" id="notesTextSizeSlider" min="8" max="16" value="11" step="1"
                        oninput="updateNotesTextSize(this.value)" class="notes-text-size-slider">
                </div>
            </div>

            <!-- Campo de Hora (opcional) -->
            <div class="notes-time-container">
                <label class="notes-time-label">🕐 Hora del evento (opcional):</label>
                <input type="time" id="notesTimeInput" class="notes-time-input" placeholder="HH:MM">
            </div>

            <!-- Selector de visibilidad -->
            <div class="notes-visibility-container">
                <label class="notes-visibility-label">👥 Visibilidad:</label>
                <div class="notes-visibility-options">
                    <label class="notes-private-label">
                        <input type="checkbox" id="notesPrivateCheck" class="notes-visibility-checkbox">
                        <span>🔒 Solo yo</span>
                    </label>
                </div>
                <div id="notesUserSelection" class="notes-user-selection" style="display: none;">
                    <!-- Los checkboxes de usuarios se generarán aquí dinámicamente -->
                </div>
            </div>

            <!-- Botones de acción -->
            <div class="notes-action-buttons">
                <button class="action-btn delete-btn" onclick="deleteNote()">BORRAR</button>
                <div class="action-buttons-row" style="display: flex !important; gap: 12px; width: 100%;">
                    <button class="action-btn cancel-btn" onclick="cancelNotesPopup()"
                        style="flex: 1; background: white; border: 2px solid #f44336; color: #f44336; padding: 12px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">CANCELAR</button>
                    <button class="action-btn accept-btn" onclick="acceptNotesPopup()"
                        style="flex: 1; background: white; border: 2px solid #4CAF50; color: #4CAF50; padding: 12px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">ACEPTAR</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Configuración de Alarma -->
    <div class="alarm-modal" id="alarmModal" onclick="handleAlarmModalClick(event)">
        <div class="alarm-modal-content" onclick="event.stopPropagation()">
            <!-- Header naranja -->
            <div class="alarm-modal-header">
                <div class="alarm-modal-title">Configurar Alarma</div>
                <button class="alarm-modal-close" onclick="closeAlarmModal()">×</button>
            </div>

            <!-- Contenido -->
            <div class="alarm-modal-body">
                <div class="alarm-input-group">
                    <label class="alarm-input-label">Fecha:</label>
                    <input type="date" id="alarmDateInput" class="alarm-input" />
                </div>

                <div class="alarm-input-group">
                    <label class="alarm-input-label">Hora:</label>
                    <input type="time" id="alarmTimeInput" class="alarm-input" />
                </div>

                <div class="action-buttons-row"
                    style="display: flex !important; gap: 12px; width: 100%; margin-top: 20px;">
                    <button class="action-btn accept-btn" onclick="addAlarm()"
                        style="flex: 1; background: white; border: 2px solid #4CAF50; color: #4CAF50; padding: 12px 20px; border-radius: 8px; font-weight: bold; cursor: pointer;">AGREGAR</button>
                </div>

                <!-- Lista de alarmas existentes -->
                <div class="alarm-list" id="alarmList">
                    <!-- Las alarmas se cargarán aquí -->
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Selección de Usuario (Nuevo para iPhone Fix) -->
    <div class="modal" id="userModal">
        <div class="modal-content-exact" style="max-width: 400px; margin: auto; border-radius: 12px; overflow: hidden;">
            <div class="modal-header-blue" style="justify-content: space-between;">
                <div class="header-date">Seleccionar Usuario</div>
                <button class="back-arrow" onclick="closeUserModal()" style="font-size: 20px;">×</button>
            </div>
            <div class="main-content-card"
                style="flex-direction: column; padding: 10px; gap: 8px; background: #f5f5f5;">
                <style>
                    .user-option {
                        display: flex;
                        align-items: center;
                        padding: 12px;
                        background: white;
                        border-radius: 8px;
                        margin-bottom: 8px;
                        cursor: pointer;
                        border: 1px solid #ddd;
                        transition: background 0.2s;
                    }

                    .user-option:active {
                        background: #eee;
                    }

                    .user-option.selected {
                        border: 2px solid #2196F3;
                        background: #E3F2FD;
                    }

                    .user-option-avatar {
                        width: 32px;
                        height: 32px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        margin-right: 12px;
                    }

                    .user-option-info {
                        flex: 1;
                    }

                    .user-option-name {
                        font-weight: 600;
                        font-size: 14px;
                    }

                    .user-option-id {
                        font-size: 11px;
                        color: #666;
                    }

                    .user-option-check {
                        color: #2196F3;
                        font-weight: bold;
                    }
                </style>
                <div id="userSelectionList" style="width: 100%;">
                    <!-- Se llena dinámicamente -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // DETECCIÓN DE PLATAFORMA (CRÍTICO PARA iOS)
        // ============================================
        // Estas variables DEBEN estar al inicio para detectar iOS standalone correctamente
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isAndroid = /Android/i.test(navigator.userAgent);

        // Detectar si está en modo standalone (PWA instalada) - IMPORTANTE para iOS
        // iOS usa window.navigator.standalone, Android usa display-mode
        const isStandaloneMode = (window.navigator.standalone === true) ||
            window.matchMedia('(display-mode: standalone)').matches ||
            document.referrer.includes('android-app://');

        // Log para debugging
        if (isIOS) {
            console.log('📱 iOS detectado');
            console.log('📱 Navigator standalone:', window.navigator.standalone);
            console.log('📱 Modo standalone detectado:', isStandaloneMode);
        }

        // Estado global
        let currentDate = new Date();
        let currentUserId = 1;
        let selectedDate = null;
        let db = null;
        let isFirebaseConnected = false;
        let users = [];
        let shiftTemplates = [];
        let recurringEventsDefinitions = []; // Definiciones de eventos recurrentes

        // Configuración de Firebase (configuración real del proyecto)
        const firebaseConfig = {
            apiKey: "AIzaSyB5vvp7IQOZLO7LlsUY_Wq-H8M_5PH3ZQE",
            authDomain: "apptaxi-f2190.firebaseapp.com",
            projectId: "apptaxi-f2190",
            storageBucket: "apptaxi-f2190.firebasestorage.app",
            messagingSenderId: "804273724178",
            appId: "1:804273724178:web:c5955a1f657884c0e7f1cb",
            measurementId: "G-3D8R30TYTM"
        };

        const monthNames = [
            'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio',
            'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
        ];

        // Días de la semana (se obtiene dinámicamente según configuración)
        function weekDays() { return getWeekDays(); }

        // Variables globales
        let isRendering = false;
        let renderTimeout = null;
        let lastRenderTime = 0;
        let eventsCache = {}; // Cache de eventos para evitar múltiples llamadas a Firebase



        // Inicializar Firebase
        async function initFirebase() {
            try {
                // Inicializar Firebase
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                isFirebaseConnected = true;
                console.log('✅ Firebase conectado correctamente');


                // Cargar usuarios desde Firebase
                await loadUsersFromFirebase();

                // Cargar shift templates
                await loadShiftTemplates();

                // Cargar eventos recurrentes y generar ocurrencias
                await loadRecurringEvents();

                // Configurar listener para cambios en tiempo real
                setupRealtimeListener();

                return true;
            } catch (error) {
                console.error('❌ Error conectando Firebase:', error);
                isFirebaseConnected = false;

                // Usar usuarios por defecto si Firebase falla
                loadDefaultUsers();
                return false;
            }
        }

        // Cargar usuarios desde Firebase
        async function loadUsersFromFirebase() {
            if (!isFirebaseConnected) {
                console.log('⚠️ Firebase no conectado, usando usuarios por defecto');
                loadDefaultUsers();
                return;
            }

            try {
                const snapshot = await db.collection('users').get();

                if (snapshot.empty) {
                    console.log('⚠️ No hay usuarios en Firebase, usando usuarios por defecto');
                    loadDefaultUsers();
                    await saveUsersToFirebase();
                } else {
                    users = snapshot.docs.map(doc => {
                        const data = doc.data();
                        return {
                            id: parseInt(data.id) || parseInt(doc.id),
                            name: data.name || `Usuario ${doc.id}`,
                            color: data.color || '#9E9E9E'
                        };
                    });
                    console.log('✅ Usuarios cargados desde Firebase:', users.length, users);
                }
            } catch (error) {
                console.error('❌ Error cargando usuarios:', error);
                // Si hay error (quota exceeded, etc.), desactivar Firebase
                if (error.message && error.message.includes('quota')) {
                    console.error('⚠️ Cuota de Firebase excedida, desactivando Firebase para esta sesión');
                    isFirebaseConnected = false;
                }
                loadDefaultUsers();
            }
        }

        // Cargar usuarios por defecto
        function loadDefaultUsers() {
            users = [
                { id: 1, name: 'Usuario 1', color: '#2196F3' },
                { id: 2, name: 'Usuario 2', color: '#4CAF50' },
                { id: 3, name: 'Usuario 3', color: '#FF9800' },
                { id: 4, name: 'Usuario 4', color: '#9C27B0' }
            ];
        }

        // Guardar usuarios en Firebase
        async function saveUsersToFirebase() {
            if (!isFirebaseConnected) return;

            try {
                for (const user of users) {
                    await db.collection('users').doc(user.id.toString()).set({
                        id: user.id,
                        name: user.name,
                        color: user.color,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                console.log('✅ Usuarios guardados en Firebase');
            } catch (error) {
                console.error('❌ Error guardando usuarios:', error);
            }
        }

        // Cargar shift templates desde Firebase
        async function loadShiftTemplates() {
            if (!isFirebaseConnected) return;

            try {
                const snapshot = await db.collection('shifts').get();
                shiftTemplates = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));

                // Asegurar que todos los turnos tengan un campo 'order'
                shiftTemplates.forEach((shift, index) => {
                    if (typeof shift.order === 'undefined') {
                        shift.order = index;
                    }
                });

                // Ordenar por el campo 'order'
                shiftTemplates.sort((a, b) => (a.order || 0) - (b.order || 0));

                console.log('✅ Shift templates cargados:', shiftTemplates.length);
            } catch (error) {
                console.error('❌ Error cargando shift templates:', error);
                // Si hay error (quota exceeded, etc.), desactivar Firebase
                if (error.message && error.message.includes('quota')) {
                    console.error('⚠️ Cuota de Firebase excedida, desactivando Firebase para esta sesión');
                    isFirebaseConnected = false;
                }
                // Usar templates por defecto si falla
                shiftTemplates = [
                    { id: '1', name: 'D1', colorHex: '#FF5722', abbreviation: 'D1', order: 0 },
                    { id: '2', name: 'D2', colorHex: '#4CAF50', abbreviation: 'D2', order: 1 },
                    { id: '3', name: 'N1', colorHex: '#9C27B0', abbreviation: 'N1', order: 2 },
                    { id: '4', name: 'Libre', colorHex: '#607D8B', abbreviation: 'Lib', order: 3 },
                    { id: '5', name: 'Tarde', colorHex: '#FF9800', abbreviation: 'T', order: 4 },
                    { id: '6', name: 'Mañana', colorHex: '#2196F3', abbreviation: 'M', order: 5 }
                ];
            }
        }

        // Configurar listener en tiempo real
        function setupRealtimeListener() {
            if (!isFirebaseConnected) return;

            // Listener para usuarios: actualizar colores si cambian
            db.collection('users').onSnapshot((snapshot) => {
                console.log('🔄 Cambios detectados en users');
                const updatedUsers = snapshot.docs.map(doc => {
                    const data = doc.data();
                    return {
                        id: parseInt(data.id) || parseInt(doc.id),
                        name: data.name || `Usuario ${doc.id}`,
                        color: data.color || '#9E9E9E'
                    };
                });
                users = updatedUsers;
                console.log('✅ Usuarios actualizados:', users);
                // Re-renderizar el calendario para aplicar nuevos colores
                scheduleRenderCalendar();
            }, (error) => {
                console.error('❌ Error en listener de users:', error);
            });

            // Listener SOLO para shifts: si se edita un turno (nombre/color/abreviatura),
            // actualizamos plantillas y re-renderizamos el calendario.
            db.collection('shifts').onSnapshot((snapshot) => {
                console.log('🔄 Cambios detectados en shifts');
                shiftTemplates = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));

                // Asegurar que todos los turnos tengan un campo 'order'
                shiftTemplates.forEach((shift, index) => {
                    if (typeof shift.order === 'undefined') {
                        shift.order = index;
                    }
                });

                // Ordenar por el campo 'order'
                shiftTemplates.sort((a, b) => (a.order || 0) - (b.order || 0));

                scheduleRenderCalendar();
            }, (error) => {
                console.error('❌ Error en listener de shifts:', error);
            });

            // Listener para eventos del calendario: actualizar caché por doc cambiado
            db.collection('calendar_events').onSnapshot((snapshot) => {
                if (!eventsCache.events) eventsCache.events = {};
                snapshot.docChanges().forEach(change => {
                    const id = change.doc.id; // dateKey YYYY-MM-DD
                    const data = change.doc.data();
                    if (change.type === 'removed') {
                        eventsCache.events[id] = [];
                    } else {
                        eventsCache.events[id] = data?.events || [];
                    }
                });
                // Refrescar vistas activas
                scheduleRenderCalendar();
                const yearView = document.getElementById('yearView');
                if (yearView && yearView.style.display !== 'none') {
                    renderYear();
                }
            }, (error) => {
                console.error('❌ Error en listener de calendar_events:', error);
            });

            // Listener para eventos recurrentes: recargar definiciones
            db.collection('recurring_events').onSnapshot((snapshot) => {
                console.log('🔄 Cambios detectados en recurring_events');
                recurringEventsDefinitions = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                console.log('✅ Definiciones de eventos recurrentes actualizadas:', recurringEventsDefinitions.length);
                // Re-renderizar el calendario para aplicar cambios
                scheduleRenderCalendar();
            }, (error) => {
                console.error('❌ Error en listener de recurring_events:', error);
            });
        }

        // Inicializar
        // Flag para evitar inicialización múltiple
        let isInitialized = false;

        async function init() {
            // Fix Year Display
            const yearDisplay = document.getElementById('currentYearDisplay');
            if (yearDisplay) {
                yearDisplay.textContent = new Date().getFullYear();
            }
            // Evitar inicialización múltiple
            if (isInitialized) {
                console.log('⚠️ Calendario ya inicializado, omitiendo...');
                return;
            }
            isInitialized = true;
            window.calendarInitialized = true;

            console.log('📅 Inicializando calendario...');
            console.log('📱 Modo standalone:', isStandaloneMode);
            console.log('📱 iOS detectado:', isIOS);
            console.log('📱 Android detectado:', isAndroid);

            // Verificar si se solicita refresh (viniendo de recurring-events)
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('refresh') === '1') {
                console.log('🔄 Refresh solicitado, limpiando caché');
                eventsCache = {}; // Limpiar caché
                window.location.search = ''; // Limpiar URL
            }

            // Aplicar tema y configuración persistida
            applySettings();


            // Cargar usuario guardado
            const savedUserId = localStorage.getItem('current_user_id');
            if (savedUserId) {
                currentUserId = parseInt(savedUserId);
            }

            // Intentar conectar Firebase
            if (!(await initFirebase())) {

            }

            // Agregar algunos eventos de prueba
            addTestEvents();

            // Soporte de salto desde Resumen: ajustar mes/día si hay 'jump_to_date'
            const jump = localStorage.getItem('jump_to_date');
            if (jump) {
                try {
                    const [y, m, d] = jump.split('-').map(Number);
                    currentDate = new Date(y, m - 1, d);
                } catch (e) { console.warn('jump_to_date inválido', e); }
                localStorage.removeItem('jump_to_date');
            }

            // Asegurar que el tab de calendario esté activo al iniciar
            ensureCalendarTabActive();

            // Renderizar calendario solo una vez
            setTimeout(() => {
                renderCalendar();
                updateCurrentUserInfo();
                // Abrir modal si se solicitó salto exacto a día
                if (jump) {
                    const [y, m, d] = jump.split('-').map(Number);
                    const dt = new Date(y, m - 1, d);
                    setTimeout(() => openDayModal(dt), 300);
                }
            }, 100);

            // Solicitar permiso para notificaciones al iniciar
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    console.log('📱 Permiso de notificaciones:', permission);
                });
            }

            // Registrar Service Workers
            if ('serviceWorker' in navigator) {
                // Primero registrar Service Worker principal para PWA (requerido para instalación)
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('✅ Service Worker principal registrado:', registration.scope);

                        // Luego registrar Service Worker de alarmas (solo si no es iOS)
                        if (!isIOS) {
                            return navigator.serviceWorker.register('./sw-alarm.js');
                        }
                    })
                    .then((registration) => {
                        if (registration) {
                            console.log('✅ Service Worker de alarmas registrado:', registration.scope);
                        }
                    })
                    .catch((error) => {
                        console.error('❌ Error registrando Service Worker:', error);
                        // Si falla sw.js, intentar solo sw-alarm.js en Android
                        if (isAndroid && !isIOS) {
                            navigator.serviceWorker.register('./sw-alarm.js')
                                .then((reg) => console.log('✅ Service Worker de alarmas registrado:', reg.scope))
                                .catch((err) => console.error('❌ Error registrando SW de alarmas:', err));
                        }
                    });
            } else if (isIOS) {
                console.log('ℹ️ iOS detectado: Service Worker tiene limitaciones, usando verificación local');
            }

            // Escuchar mensajes del Service Worker
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'OPEN_ALARM') {
                        window.location.href = event.data.url;
                    } else if (event.data && event.data.type === 'SHOW_ALARM') {
                        // Mostrar la pantalla de alarma cuando el Service Worker no puede abrir ventana
                        const { url, date, time, note, user } = event.data;
                        openAlarmNotificationPage(date, time, note);
                    }
                });
            }

            // Guardar alarmas en localStorage para verificación cuando la app se abre (especialmente para iOS)
            saveAlarmsToLocalStorage();

            // Verificar alarmas pendientes al abrir la app
            checkPendingAlarmsOnStart();

            // Detectar cuando la app vuelve al primer plano (importante para iOS)
            setupVisibilityChangeListener();

            // Detectar cuando la app se convierte en PWA instalada
            checkPWAInstallation();

            // Mostrar botón de instalación en Android si no está instalada
            if (isAndroid) {
                setupAndroidInstallPrompt();
            }

            // Iniciar verificación de alarmas después de un breve delay
            setTimeout(() => {
                setupAlarmNotifications();
                if (!isIOS) {
                    scheduleAllAlarms(); // Programar todas las alarmas existentes en Service Worker
                } else {
                    // En iOS, programar alarmas en localStorage para verificación periódica
                    scheduleAlarmsForIOS();
                }
            }, 2000);
        }

        // Configuración
        const SETTINGS_KEY = 'app_settings_v1';
        function loadSettings() {
            try { return JSON.parse(localStorage.getItem(SETTINGS_KEY)) || { theme: 'system', weekStart: 'monday', highlightToday: true, smartWeeks: true }; } catch (e) { return { theme: 'system', weekStart: 'monday', highlightToday: true, smartWeeks: true }; }
        }
        function saveSettings() {
            const st = loadSettings();
            st.theme = document.getElementById('stTheme').value;
            st.weekStart = document.getElementById('stWeekStart').value;
            st.highlightToday = document.getElementById('stHighlightToday').checked;
            st.smartWeeks = document.getElementById('stSmartWeeks').checked;
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(st));
            applySettings();
            closeSettings();
            // Re-render para aplicar semana y estilos
            renderCalendar(true);
        }
        function resetSettings() { localStorage.removeItem(SETTINGS_KEY); applySettings(); closeSettings(); renderCalendar(true); }
        function openSettings() {
            const st = loadSettings();
            document.getElementById('stTheme').value = st.theme || 'system';
            document.getElementById('stWeekStart').value = st.weekStart || 'monday';
            document.getElementById('stHighlightToday').checked = st.highlightToday !== false;
            document.getElementById('stSmartWeeks').checked = st.smartWeeks !== false;
            document.getElementById('settingsModal').classList.add('show');

            // Actualizar botones de tema
            updateThemeButtons(st.theme || 'system');
        }

        function updateThemeButtons(selectedTheme) {
            const buttons = document.querySelectorAll('.theme-option');
            buttons.forEach(btn => {
                if (btn.dataset.theme === selectedTheme) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function selectTheme(theme) {
            // Actualizar el select oculto
            document.getElementById('stTheme').value = theme;

            // Actualizar botones visuales
            updateThemeButtons(theme);

            // Agregar animación
            document.body.classList.add('theme-transition');
            setTimeout(() => {
                document.body.classList.remove('theme-transition');
            }, 500);

            // Aplicar el tema inmediatamente para preview
            if (theme === 'dark') {
                document.documentElement.style.colorScheme = 'dark';
                document.body.classList.add('dark-theme');
                document.body.classList.remove('light-theme');
            } else if (theme === 'light') {
                document.documentElement.style.colorScheme = 'light';
                document.body.classList.add('light-theme');
                document.body.classList.remove('dark-theme');
            } else {
                document.documentElement.style.colorScheme = 'normal';
                document.body.classList.remove('dark-theme', 'light-theme');
            }
        }
        function closeSettings(ev) { if (ev && ev.target && !ev.target.classList) { } document.getElementById('settingsModal').classList.remove('show'); }
        function applySettings() {
            const st = loadSettings();
            // Tema
            if (st.theme === 'dark') {
                document.documentElement.style.colorScheme = 'dark';
                document.body.classList.add('dark-theme');
                document.body.classList.remove('light-theme');
            } else if (st.theme === 'light') {
                document.documentElement.style.colorScheme = 'light';
                document.body.classList.add('light-theme');
                document.body.classList.remove('dark-theme');
            } else {
                document.documentElement.style.colorScheme = 'normal';
                document.body.classList.remove('dark-theme', 'light-theme');
            }
        }
        // Utilidad: días de la semana según configuración
        function getWeekDays() {
            const st = loadSettings();
            const base = ['Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb', 'Dom'];
            if (st.weekStart === 'sunday') return ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
            return base;
        }

        // Asegurar que el tab de calendario esté activo
        function ensureCalendarTabActive() {
            // Verificar parámetros de URL que puedan cambiar el tab
            const urlParams = new URLSearchParams(window.location.search);
            const tabParam = urlParams.get('tab');

            // Si hay un parámetro tab=summary, eliminarlo y quedarse en calendario
            if (tabParam === 'summary') {
                // Limpiar parámetro y redirigir a calendario limpio
                const newUrl = window.location.pathname;
                window.history.replaceState({}, '', newUrl);
            }

            // Asegurar que el tab de calendario esté visible
            const calendarBtn = document.querySelector('.tab-btn[onclick*="calendar"]');
            const yearBtn = document.querySelector('.tab-btn[onclick*="year"]');
            const summaryBtn = document.querySelector('.tab-btn[onclick*="summary"]');

            // Remover active de todos
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Activar solo el de calendario
            if (calendarBtn) {
                calendarBtn.classList.add('active');
            }

            // Mostrar calendario y ocultar año
            const mainGridContainer = document.querySelector('.calendar-container');
            const yearView = document.getElementById('yearView');
            const monthNav = document.querySelector('.month-nav');

            if (monthNav) monthNav.style.display = 'flex';
            if (yearView) yearView.style.display = 'none';
            if (mainGridContainer) mainGridContainer.style.display = 'block';
        }

        // Mostrar tabs
        function showTab(tab) {
            // Remover active de todos los botones
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Agregar active al botón clickeado
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Si no hay event, activar el botón correspondiente
                const targetBtn = document.querySelector(`.tab-btn[onclick*="${tab}"]`);
                if (targetBtn) targetBtn.classList.add('active');
            }

            // Mostrar/ocultar vistas
            const mainGridContainer = document.querySelector('.calendar-container');
            const yearView = document.getElementById('yearView');
            const monthNav = document.querySelector('.month-nav');

            if (tab === 'year') {
                if (monthNav) monthNav.style.display = 'none';
                mainGridContainer.style.display = 'none';
                yearView.style.display = 'block';
                updateYearNav();
                renderYear();
                // Precarga en segundo plano para que aparezcan todos los turnos del año
                const yr = yearViewYear ?? currentDate.getFullYear();
                preloadYearEvents(yr);
            } else if (tab === 'calendar') {
                if (monthNav) monthNav.style.display = 'flex';
                yearView.style.display = 'none';
                mainGridContainer.style.display = 'block';
            } else if (tab === 'summary') {
                window.location.href = 'summary.html';
            }
        }

        // Activar modo pintar
        function activatePaintMode() {
            console.log('🎨 Activando modo pintar...');
            // Mostrar el pop-up de selección de turnos
            openShiftsPopup();
        }

        // Abrir pop-up de turnos
        async function openShiftsPopup() {
            console.log('📂 Abriendo pop-up de turnos...');
            const popup = document.getElementById('shiftsPopup');

            if (!popup) {
                console.error('❌ No se encontró el elemento shiftsPopup');
                return;
            }

            console.log('✅ Pop-up encontrado, agregando clase show...');

            // Mostrar pop-up: remover atributo hidden y agregar clase show
            popup.removeAttribute('hidden');
            popup.classList.add('show');
            await renderShiftsForPainting();
            console.log('✅ Pop-up abierto');
        }

        // Cerrar pop-up de turnos
        function closeShiftsPopup() {
            const popup = document.getElementById('shiftsPopup');

            // Ocultar pop-up: agregar atributo hidden y remover clase show
            popup.setAttribute('hidden', '');
            popup.classList.remove('show');

            // Salir del modo pintura si estaba activo
            exitPaintMode();
        }

        // Renderizar turnos en el pop-up
        async function renderShiftsForPainting() {
            console.log('🎨 Renderizando turnos para pintar...');
            const container = document.getElementById('shiftsScroll');
            if (!container) {
                console.error('❌ No se encontró el contenedor shiftsScroll');
                return;
            }
            container.innerHTML = '';

            console.log('📊 Turnos disponibles:', shiftTemplates.length);

            // Si no hay turnos, intentar cargarlos
            if (shiftTemplates.length === 0) {
                console.log('⚠️ No hay turnos, intentando cargarlos...');
                if (isFirebaseConnected) {
                    await loadShiftTemplates();
                }

                // Si aún no hay turnos, mostrar mensaje
                if (shiftTemplates.length === 0) {
                    console.log('❌ Aún no hay turnos disponibles');
                    container.innerHTML = '<div style="padding: 16px; color: #999; text-align: center; width: 100%;">No hay turnos disponibles<br/>Crea turnos en la sección "TURNOS"</div>';
                    return;
                }
            }

            console.log('✅ Renderizando', shiftTemplates.length, 'turnos...');
            // Renderizar cada turno
            shiftTemplates.forEach(shift => {
                const button = document.createElement('button');
                button.className = 'shift-button-paint';

                // Determinar el color de fondo
                const backgroundColor = shift.backgroundColor || shift.colorHex || shift.color || '#9E9E9E';
                button.style.backgroundColor = backgroundColor;

                // Usar la abreviatura si existe, sino el nombre
                const displayText = shift.abbreviation || shift.name || 'Turno';
                button.textContent = displayText;

                // Evento click para pintar con este turno
                button.onclick = () => selectShiftForPainting(shift);

                container.appendChild(button);
            });

            // Añadir botón de borrar
            const deleteButton = document.createElement('button');
            deleteButton.className = 'shift-button-delete';
            deleteButton.innerHTML = '🗑️';
            deleteButton.title = 'Borrar turnos del día seleccionado';
            deleteButton.onclick = () => selectDeleteMode();
            container.appendChild(deleteButton);

            console.log('✅ Turnos renderizados correctamente');
        }

        // Variable para almacenar el turno seleccionado para pintar
        let selectedShiftForPainting = null;
        let isDeleteMode = false;

        // Seleccionar turno para pintar
        function selectShiftForPainting(shift) {
            selectedShiftForPainting = shift;
            // NO cerrar el pop-up - se mantiene abierto

            // Cambiar el cursor a "modo pintura"
            document.body.style.cursor = 'crosshair';

            // Agregar event listeners a las celdas del calendario
            const dayCells = document.querySelectorAll('.calendar-day');
            dayCells.forEach(cell => {
                // Crear nuevo onclick que pinta
                const paintOnclick = (e) => {
                    // Prevenir que se abra el modal de detalles del día
                    e.stopPropagation();
                    // Pintar el día con el turno seleccionado
                    paintDay(cell, shift);
                    // NO salir del modo pintura - permitir seguir pintando
                };

                cell.onclick = paintOnclick;
                cell.style.cursor = 'pointer';
            });

            // No mostrar alert - el pop-up permanece visible
            console.log(`🎨 Modo PINTAR activo - Turno: ${shift.name || shift.abbreviation}`);
        }

        // Salir del modo pintura
        function exitPaintMode() {
            document.body.style.cursor = '';
            selectedShiftForPainting = null;
            isDeleteMode = false;

            // Restaurar el cursor de las celdas (no re-renderizar para evitar flashes)
            const dayCells = document.querySelectorAll('.calendar-day');
            dayCells.forEach(cell => {
                cell.style.cursor = '';
                // Restaurar handler por defecto: abrir modal del día
                const dateStr = cell.dataset.date;
                if (dateStr) {
                    const dateObj = new Date(dateStr);
                    cell.onclick = (e) => {
                        e.stopPropagation();
                        openDayModal(dateObj);
                    };
                } else {
                    cell.onclick = null;
                }
            });

            console.log('✅ Modo pintura desactivado');
        }

        // Seleccionar modo borrar
        function selectDeleteMode() {
            isDeleteMode = true;
            selectedShiftForPainting = null;

            // Cambiar el cursor a "modo borrar"
            document.body.style.cursor = 'not-allowed';

            // Agregar event listeners a las celdas del calendario
            const dayCells = document.querySelectorAll('.calendar-day');
            dayCells.forEach(cell => {
                const deleteOnclick = (e) => {
                    e.stopPropagation();
                    deleteDayShifts(cell);
                };

                cell.onclick = deleteOnclick;
                cell.style.cursor = 'not-allowed';
            });

            console.log('🗑️ Modo BORRAR activo');
        }

        // Borrar turnos de un día
        async function deleteDayShifts(cell) {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;

            const date = new Date(dateStr);
            const dateKey = formatDateKey(date);

            console.log('🗑️ Borrando turnos del día:', dateKey);

            try {
                if (isFirebaseConnected) {
                    // Eliminar el documento completo del día
                    await db.collection('calendar_events').doc(dateKey).delete();
                    console.log('✅ Turnos eliminados de Firebase');
                } else {
                    // Eliminar localmente
                    await saveEventsToLocalStorage(date, []);
                }

                // Agregar eventos recurrentes (ya que solo borramos los no-recurrentes)
                const eventsWithRecurring = await addRecurringEventsToDay([], date);

                // Actualizar solo la visualización de este día
                updateDayDisplay(cell, eventsWithRecurring);

            } catch (error) {
                console.error('❌ Error borrando turnos:', error);
            }
        }

        // Pintar un día con un turno
        async function paintDay(cell, shift) {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;
            if (!shift) {
                console.warn('⚠️ paintDay llamado sin shift válido');
                return;
            }

            const date = new Date(dateStr);
            const dateKey = formatDateKey(date);

            console.log('🎨 Pintando día:', dateKey, 'con turno:', shift);

            try {
                // Obtener eventos existentes del día
                const existingEvents = await getEventsForDate(date);

                // Verificar si ya existe este turno
                const shiftText = (shift && (shift.abbreviation || shift.name)) || 'Turno';
                const exists = existingEvents.some(evt => (evt.shiftId && evt.shiftId === shift.id) || evt.text === shiftText);

                if (exists) {
                    console.log('⚠️ Ya existe un evento para este día con este turno');
                    return; // No mostrar alert para no interrumpir el flujo
                }

                // Crear nuevo evento
                const newEvent = {
                    text: shiftText,
                    shiftId: shift.id,
                    userId: currentUserId,
                    userColor: shift.backgroundColor || shift.colorHex || shift.color,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                // Agregar el nuevo evento a la lista
                existingEvents.push(newEvent);

                if (isFirebaseConnected) {
                    // Guardar en Firebase
                    await db.collection('calendar_events').doc(dateKey).set({
                        events: existingEvents
                    }, { merge: true });
                    console.log('✅ Turno guardado en Firebase');
                } else {
                    // Guardar localmente
                    await saveEventsToLocalStorage(date, existingEvents);
                }

                // Agregar eventos recurrentes antes de actualizar la visualización
                const eventsWithRecurring = await addRecurringEventsToDay(existingEvents, date);

                // Actualizar solo la visualización de este día sin re-renderizar todo
                updateDayDisplay(cell, eventsWithRecurring);

            } catch (error) {
                console.error('❌ Error pintando día:', error);
            }
        }

        // Actualizar visualización de un día sin re-renderizar todo el calendario
        async function updateDayDisplay(cell, events) {
            const dateStr = cell.dataset.date;
            if (!dateStr) return;

            const date = new Date(dateStr);
            const dateKey = formatDateKey(date);

            // Actualizar la caché con los eventos (sin recurrentes, que se calculan dinámicamente)
            if (!eventsCache.events) eventsCache.events = {};
            eventsCache.events[dateKey] = events.filter(e => e.type !== 'recurring');

            // Filtrar solo turnos (excluir notas y eventos recurrentes)
            const shifts = events
                .filter(event => event.type !== 'note' && event.type !== 'recurring')
                .map(e => normalizeShiftEvent(e));

            // Obtener el número del día
            const dayNumber = cell.querySelector('.day-number');
            if (!dayNumber) return;

            // Limpiar estilo anterior de la celda
            cell.style.background = '';
            cell.style.backgroundColor = '';
            cell.style.backgroundImage = '';

            // Limpiar eventos visuales previos
            const eventsEl = cell.querySelector('.day-events');
            if (eventsEl) {
                eventsEl.remove();
            }

            // Limpiar textos de turnos previos
            const shiftTexts = cell.querySelectorAll('.shift-text-full, .shift-text-half, .event-badge');
            shiftTexts.forEach(el => el.remove());

            // Limpiar iconos de categoría previos
            const categoryIconsEl = cell.querySelector('.category-icons');
            if (categoryIconsEl) {
                categoryIconsEl.remove();
            }

            // Limpiar texto de nota previo
            const noteTextEl = cell.querySelector('.note-text');
            if (noteTextEl) {
                noteTextEl.remove();
            }

            // SIEMPRE mostrar el número del día, pero con estilo para que sea visible
            dayNumber.style.display = 'block';
            dayNumber.style.position = 'absolute';
            dayNumber.style.top = '2px';
            dayNumber.style.right = '2px';
            dayNumber.style.zIndex = '100';
            dayNumber.style.fontWeight = '600';
            dayNumber.style.fontSize = '11px';

            if (shifts.length > 0) {
                if (cell.classList.contains('other-month')) {
                    cell.classList.remove('other-month');
                    cell.style.opacity = '1';
                }

                if (shifts.length === 1) {
                    // Un solo turno: pintar toda la celda
                    const template = getTemplateForEvent(shifts[0]);
                    const color = template ? (template.backgroundColor || template.colorHex || template.color) :
                        (shifts[0].backgroundColor || shifts[0].colorHex || shifts[0].color || shifts[0].userColor || getUserColor(shifts[0].userId));

                    cell.style.backgroundColor = color;

                    // Número del día en esquina superior derecha, sin fondo
                    dayNumber.style.backgroundColor = '';
                    dayNumber.style.padding = '';
                    dayNumber.style.borderRadius = '';
                    dayNumber.style.color = '#ffffff';
                    dayNumber.style.textShadow = '0 0 3px rgba(0,0,0,0.7)';

                    // Crear texto del turno centrado
                    const shiftText = document.createElement('div');
                    shiftText.className = 'shift-text-full';
                    shiftText.textContent = template ? (template.abbreviation || template.name) : shifts[0].text;
                    const fontSize = getShiftFontSize(template, 13);
                    shiftText.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    cell.appendChild(shiftText);

                } else if (shifts.length === 2) {
                    // Dos turnos: dividir la celda en dos
                    const shift1 = shifts[0];
                    const shift2 = shifts[1];

                    const template1 = getTemplateForEvent(shift1);
                    const template2 = getTemplateForEvent(shift2);

                    const color1 = template1 ? (template1.backgroundColor || template1.colorHex || template1.color) :
                        (shift1.backgroundColor || shift1.colorHex || shift1.color || shift1.userColor || getUserColor(shift1.userId));
                    const color2 = template2 ? (template2.backgroundColor || template2.colorHex || template2.color) :
                        (shift2.backgroundColor || shift2.colorHex || shift2.color || shift2.userColor || getUserColor(shift2.userId));

                    // Usar gradiente lineal para dividir en dos
                    cell.style.background = `linear-gradient(to bottom, ${color1} 50%, ${color2} 50%)`;

                    // Número del día sin fondo, con sombra para contraste
                    dayNumber.style.backgroundColor = '';
                    dayNumber.style.padding = '';
                    dayNumber.style.borderRadius = '';
                    dayNumber.style.color = '#ffffff';
                    dayNumber.style.textShadow = '0 0 3px rgba(0,0,0,0.7)';

                    // Crear texto para cada mitad
                    const text1 = document.createElement('div');
                    text1.className = 'shift-text-half';
                    text1.textContent = template1 ? (template1.abbreviation || template1.name) : shift1.text;
                    const fontSize1 = getShiftFontSize(template1, 12);
                    text1.style.cssText = `
                        position: absolute;
                        top: 25%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize1}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    cell.appendChild(text1);

                    const text2 = document.createElement('div');
                    text2.className = 'shift-text-half';
                    text2.textContent = template2 ? (template2.abbreviation || template2.name) : shift2.text;
                    const fontSize2 = getShiftFontSize(template2, 12);
                    text2.style.cssText = `
                        position: absolute;
                        top: 75%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize2}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    cell.appendChild(text2);

                } else if (shifts.length === 3) {
                    // Tres turnos: dividir en tres bandas
                    const [s1, s2, s3] = shifts;
                    const t1 = shiftTemplates.find(t => t.name === s1.text || t.abbreviation === s1.text);
                    const t2 = shiftTemplates.find(t => t.name === s2.text || t.abbreviation === s2.text);
                    const t3 = shiftTemplates.find(t => t.name === s3.text || t.abbreviation === s3.text);
                    const c1 = t1 ? (t1.backgroundColor || t1.colorHex || t1.color) : (s1.userColor || getUserColor(s1.userId));
                    const c2 = t2 ? (t2.backgroundColor || t2.colorHex || t2.color) : (s2.userColor || getUserColor(s2.userId));
                    const c3 = t3 ? (t3.backgroundColor || t3.colorHex || t3.color) : (s3.userColor || getUserColor(s3.userId));
                    cell.style.background = `linear-gradient(to bottom, ${c1} 33.333%, ${c2} 33.333% 66.666%, ${c3} 66.666%)`;

                    dayNumber.style.backgroundColor = '';
                    dayNumber.style.color = '#ffffff';
                    dayNumber.style.textShadow = '0 0 3px rgba(0,0,0,0.7)';

                    const mk = (txt, top, tmpl) => {
                        const el = document.createElement('div');
                        el.className = 'shift-text-third';
                        el.textContent = txt;
                        const fontSize = getShiftFontSize(tmpl, 11);
                        el.style.cssText = `position:absolute; top:${top}%; left:50%; transform:translate(-50%,-50%); color:white; font-weight:700; font-size:${fontSize}px; white-space:nowrap; z-index:10;`;
                        cell.appendChild(el);
                    };
                    mk(t1 ? (t1.abbreviation || t1.name) : s1.text, 16.5, t1);
                    mk(t2 ? (t2.abbreviation || t2.name) : s2.text, 50, t2);
                    mk(t3 ? (t3.abbreviation || t3.name) : s3.text, 83.5, t3);

                } else {
                    // Más de dos turnos: mostrar los primeros tres
                    shifts.slice(0, 3).forEach((event, index) => {
                        const template = getTemplateForEvent(event);
                        const color = template ? (template.backgroundColor || template.colorHex || template.color) :
                            (event.backgroundColor || event.colorHex || event.color || event.userColor || getUserColor(event.userId));

                        const eventEl = document.createElement('div');
                        eventEl.className = 'event-badge';
                        const fontSize = getShiftFontSize(template, 10);
                        eventEl.style.cssText = `
                            position: absolute;
                            top: ${20 + index * 30}%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background-color: ${color};
                            color: white;
                            padding: 2px 6px;
                            border-radius: 4px;
                            font-size: ${fontSize}px;
                            font-weight: 600;
                            z-index: 10;
                        `;
                        eventEl.textContent = template ? (template.abbreviation || template.name) : event.text;
                        cell.appendChild(eventEl);
                    });
                }
            } else {
                // No hay turnos: mostrar el número del día con estilo normal
                dayNumber.style.backgroundColor = '';
                dayNumber.style.padding = '';
                dayNumber.style.borderRadius = '';
                dayNumber.style.color = '';
            }

            // Agregar iconos de categoría con el color del usuario
            // Obtener todas las notas y eventos recurrentes (múltiples usuarios pueden tener notas)
            const notes = events.filter(event => event.type === 'note' || event.type === 'recurring');

            if (notes.length > 0) {
                // Si hay al menos una nota con texto o evento recurrente con título, ocultar los textos de los turnos para evitar superposición
                const hasAnyNoteText = notes.some(note =>
                    (note.text && note.text.trim() !== '') ||
                    (note.type === 'recurring' && note.title)
                );
                if (hasAnyNoteText) {
                    const shiftTexts = cell.querySelectorAll('.shift-text-full, .shift-text-half, .shift-text-third, .event-badge');
                    shiftTexts.forEach(el => el.style.display = 'none');
                }

                // Crear un contenedor para todas las notas
                const allNotesContainer = document.createElement('div');
                allNotesContainer.style.cssText = `
                    position: absolute;
                    top: 20px;
                    left: 2px;
                    right: 2px;
                    display: flex;
                    flex-direction: column;
                    gap: 2px;
                    z-index: 15;
                `;

                // Renderizar cada nota o evento recurrente
                notes.forEach(note => {
                    // Filtrar notas privadas y visibilidad
                    if (note.type === 'note') {
                        // Si es privada, solo mostrar al autor
                        if (note.private && note.userId !== currentUserId) {
                            return; // Omitir notas privadas que no son del usuario actual
                        }
                        // Si tiene lista de usuarios visibles, verificar si el usuario actual está incluido
                        if (note.visibleTo && Array.isArray(note.visibleTo)) {
                            if (!note.visibleTo.includes(currentUserId)) {
                                return; // Omitir si no está en la lista de visibles
                            }
                        } else if (!note.private) {
                            // Si no tiene lista visibleTo y no es privada, no mostrar a nadie (excepto al autor)
                            // Esto asegura que solo los usuarios explícitamente seleccionados puedan ver la nota
                            if (note.userId !== currentUserId) {
                                return; // Omitir si no es el autor y no tiene visibleTo
                            }
                        }
                    }

                    if (note.type === 'recurring' && note.title) {
                        // Renderizar evento recurrente
                        const lineUserColor = getUserColor(note.userId);
                        const noteTextEl = document.createElement('div');
                        noteTextEl.className = 'note-text';

                        noteTextEl.textContent = note.title;
                        const noteFontSize = 11;
                        noteTextEl.style.cssText = `
                            color: ${lineUserColor};
                        font-weight: 700;
                        font-size: ${noteFontSize}px;
                            text-decoration: underline;
                            white-space: normal;
                            word-wrap: break-word;
                            overflow-wrap: break-word;
                        `;
                        allNotesContainer.appendChild(noteTextEl);
                    } else if (note.text && note.text.trim() !== '') {
                        // Dividir el texto por saltos de línea para renderizar cada línea con su color
                        const noteLines = note.text.split('\n').filter(line => line.trim() !== '');

                        noteLines.forEach((line, index) => {
                            // Usar el color del usuario que creó la nota (ya no necesitamos heurística por contenido)
                            const lineUserColor = getUserColor(note.userId);
                            const noteTextEl = document.createElement('div');
                            noteTextEl.className = 'note-text';

                            // Agregar hora a la primera línea si existe
                            let displayText = line;
                            if (index === 0 && note.time) {
                                displayText = `${line} ${note.time}`;
                            }

                            noteTextEl.textContent = displayText;
                            // Usar el tamaño guardado en la nota o el por defecto
                            const noteFontSize = note.textSize || 11;
                            const fontSize = index === 0 ? noteFontSize : noteFontSize * 0.85;
                            const fontWeight = index === 0 ? '700' : 'normal';
                            noteTextEl.style.cssText = `
                                color: ${lineUserColor};
                                font-weight: ${fontWeight};
                                font-size: ${fontSize}px;
                                white-space: normal;
                                word-wrap: break-word;
                                overflow-wrap: break-word;
                            `;
                            allNotesContainer.appendChild(noteTextEl);
                        });
                    }
                });

                if (allNotesContainer.children.length > 0) {
                    cell.appendChild(allNotesContainer);
                }

                // Agregar iconos de categoría de todas las notas
                const allCategoriesEl = document.createElement('div');
                allCategoriesEl.className = 'category-icons';

                notes.forEach(note => {
                    if (note.categories && note.categories.length > 0) {
                        note.categories.forEach(category => {
                            if (category.icon && category.icon.trim() !== '') {
                                const iconEl = document.createElement('span');
                                iconEl.className = 'category-icon';
                                iconEl.textContent = category.icon;
                                iconEl.title = category.text;
                                // Aplicar el color del usuario que creó la nota al icono
                                const noteUserColor = getUserColor(note.userId);
                                iconEl.style.color = noteUserColor;
                                iconEl.style.borderColor = noteUserColor;
                                allCategoriesEl.appendChild(iconEl);
                            }
                        });
                    }
                });

                if (allCategoriesEl.children.length > 0) {
                    cell.appendChild(allCategoriesEl);
                }
            }
        }

        // Activar modo editar
        function activateEditMode() {
            window.location.href = 'users-management.html';
        }


        // Actualizar info del usuario actual (oculto)
        function updateCurrentUserInfo() {
            const user = users.find(u => u.id === currentUserId);
            // Info del usuario oculta para maximizar espacio del calendario
            // document.getElementById('currentUserInfo').textContent = 
            //     `Usuario actual: ${user.name}`;
        }

        // Renderizar calendario con debounce
        function scheduleRenderCalendar() {
            // Cancelar render anterior si existe
            if (renderTimeout) {
                clearTimeout(renderTimeout);
            }

            // Programar nuevo render con delay
            renderTimeout = setTimeout(() => {
                renderCalendar();
            }, 200);
        }

        // Renderizar calendario
        async function renderCalendar(force = false) {
            // Prevenir renders muy frecuentes (mínimo 100ms entre renders)
            const now = Date.now();
            if (!force && now - lastRenderTime < 100) {
                console.log('⏳ Render muy frecuente, saltando...');
                return;
            }

            if (isRendering) {
                console.log('⏳ Ya se está renderizando, saltando...');
                return;
            }

            isRendering = true;
            lastRenderTime = now;
            const container = document.getElementById('calendarGrid');

            // Limpiar completamente el contenedor
            container.innerHTML = '';

            // Título del mes
            document.getElementById('monthTitle').textContent =
                `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;

            // Headers de días de la semana
            weekDays().forEach(day => {
                const header = document.createElement('div');
                header.className = 'weekday-header';
                header.textContent = day;
                container.appendChild(header);
            });

            // Calcular días del mes
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startDayOfWeek = firstDay.getDay();

            // Ajustar para que la semana empiece en lunes
            const adjustedStartDay = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

            // Cargar todos los eventos del mes de una vez (optimización)
            if (isFirebaseConnected && eventsCache.month !== `${year}-${month}`) {
                await loadAllEventsForMonth(year, month);
            }

            // Días del mes anterior (solo los necesarios para completar la primera semana)
            if (adjustedStartDay > 0) {
                const prevMonthLastDay = new Date(year, month, 0).getDate();
                for (let i = adjustedStartDay - 1; i >= 0; i--) {
                    const day = prevMonthLastDay - i;
                    const date = new Date(year, month - 1, day);
                    renderDay(container, date, true);
                }
            }

            // Días del mes actual
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                renderDay(container, date, false);
            }

            // Días del mes siguiente (completar sólo si necesitamos 6 semanas)
            const totalCellsUsed = adjustedStartDay + daysInMonth;
            const needsSixWeeks = totalCellsUsed > 35; // 5 semanas * 7 = 35

            if (needsSixWeeks) {
                const remainingCells = 42 - totalCellsUsed; // completar a 6 semanas
                if (remainingCells > 0) {
                    for (let day = 1; day <= remainingCells; day++) {
                        const date = new Date(year, month + 1, day);
                        renderDay(container, date, true);
                    }
                }
            } else {
                // Completar la última semana hasta 5 semanas (35 celdas)
                const remainingToFiveWeeks = 35 - totalCellsUsed;
                if (remainingToFiveWeeks > 0) {
                    for (let day = 1; day <= remainingToFiveWeeks; day++) {
                        const date = new Date(year, month + 1, day);
                        renderDay(container, date, true);
                    }
                }
            }

            // Ajustar grid-template-rows según número de semanas
            // 7 headers + (5 o 6 semanas de días)
            const numWeeks = needsSixWeeks ? 6 : 5;
            container.style.gridTemplateRows = `12px repeat(${numWeeks}, 1fr)`;

            isRendering = false;

            // Si estamos en modo pintura o borrar, restaurar los event listeners
            const dayCells = document.querySelectorAll('.calendar-day');

            if (selectedShiftForPainting) {
                // Modo pintura
                dayCells.forEach(cell => {
                    const paintOnclick = (e) => {
                        e.stopPropagation();
                        // Capturar referencia actual de turno; si fuese null, salir sin error
                        const shiftRef = selectedShiftForPainting;
                        if (!shiftRef) return exitPaintMode();
                        paintDay(cell, shiftRef);
                    };
                    cell.onclick = paintOnclick;
                    cell.style.cursor = 'pointer';
                });
                document.body.style.cursor = 'crosshair';
            } else if (isDeleteMode) {
                // Modo borrar
                dayCells.forEach(cell => {
                    const deleteOnclick = (e) => {
                        e.stopPropagation();
                        deleteDayShifts(cell);
                    };
                    cell.onclick = deleteOnclick;
                    cell.style.cursor = 'not-allowed';
                });
                document.body.style.cursor = 'not-allowed';
            }
        }

        // Cargar todos los eventos del mes de una vez
        async function loadAllEventsForMonth(year, month) {
            eventsCache.month = `${year}-${month}`;
            eventsCache.events = {};

            if (!isFirebaseConnected) return;

            try {
                // Calcular rango de fechas del mes
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();

                // Cargar eventos de todos los días del mes en paralelo
                const promises = [];
                for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(year, month, day);
                    const dateKey = formatDateKey(date);
                    promises.push(
                        db.collection('calendar_events').doc(dateKey).get().then(doc => {
                            if (doc.exists) {
                                eventsCache.events[dateKey] = doc.data().events || [];
                            }
                        })
                    );
                }

                await Promise.all(promises);
                console.log('✅ Eventos del mes cargados en caché');
            } catch (error) {
                console.error('❌ Error cargando eventos del mes:', error);
            }
        }

        // Añadir eventos de un mes al caché SIN resetear el resto
        async function loadEventsForMonthIntoCache(year, month) {
            if (!isFirebaseConnected) return;
            if (!eventsCache.events) eventsCache.events = {};
            try {
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                const ops = [];
                for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(year, month, day);
                    const dateKey = formatDateKey(date);
                    ops.push(
                        db.collection('calendar_events').doc(dateKey).get().then(doc => {
                            eventsCache.events[dateKey] = doc.exists ? (doc.data().events || []) : [];
                        })
                    );
                }
                await Promise.all(ops);
            } catch (e) {
                console.error('❌ Error cargando mes en caché:', e);
            }
        }

        // Precargar todo el año actual (12 meses) en segundo plano y luego refrescar vista anual
        async function preloadYearEvents(year) {
            if (!isFirebaseConnected) return;
            if (!eventsCache.events) eventsCache.events = {};
            try {
                const tasks = [];
                for (let m = 0; m < 12; m++) tasks.push(loadEventsForMonthIntoCache(year, m));
                await Promise.all(tasks);
                // Si sigue visible la vista anual, re-renderizar
                const yearView = document.getElementById('yearView');
                if (yearView && yearView.style.display !== 'none') {
                    renderYear();
                }
            } catch (e) {
                console.error('❌ Error precargando eventos del año:', e);
            }
        }

        // Renderizar un día
        function renderDay(container, date, isOtherMonth) {
            const dayEl = document.createElement('div');
            dayEl.className = 'calendar-day';
            dayEl.dataset.date = date.toISOString(); // Guardar la fecha en dataset para acceso desde fuera

            if (isOtherMonth) {
                dayEl.classList.add('other-month');
            }

            // Marcar día actual
            const today = new Date();
            if (date.toDateString() === today.toDateString()) {
                dayEl.classList.add('today');
            }

            // Número del día
            const numberEl = document.createElement('div');
            numberEl.className = 'day-number';
            numberEl.textContent = date.getDate();
            // Estilo base del número del día
            numberEl.style.position = 'absolute';
            numberEl.style.top = '2px';
            numberEl.style.right = '2px';
            numberEl.style.zIndex = '100';
            numberEl.style.fontWeight = '600';
            numberEl.style.fontSize = '11px';
            dayEl.appendChild(numberEl);

            // Eventos del día (cargar pero aplicar el nuevo estilo después)
            const eventsEl = document.createElement('div');
            eventsEl.className = 'day-events';

            // Obtener eventos del caché y agregar eventos recurrentes dinámicamente
            let events = getEventsForDateCached(date);

            // Agregar eventos recurrentes calculados dinámicamente (síncrono)
            if (recurringEventsDefinitions && recurringEventsDefinitions.length > 0) {
                for (const eventDef of recurringEventsDefinitions) {
                    try {
                        const hasOccurrence = checkIfDateMatchesRecurring(eventDef, date);
                        if (hasOccurrence) {
                            // Verificar si ya existe en eventos
                            const exists = events.some(e =>
                                e.type === 'recurring' && e.recurringEventId === eventDef.id
                            );

                            if (!exists) {
                                const recurringEvent = {
                                    type: 'recurring',
                                    recurringEventId: eventDef.id,
                                    title: eventDef.title,
                                    description: eventDef.description || '',
                                    time: eventDef.time,
                                    userId: currentUserId,
                                    userColor: getUserColor(currentUserId),
                                    createdAt: new Date().toISOString()
                                };
                                events.push(recurringEvent);
                                console.log('📅 Evento recurrente agregado en renderDay:', eventDef.title, 'para', formatDateKey(date));
                            }
                        }
                    } catch (error) {
                        console.error('Error verificando evento recurrente en renderDay:', eventDef.title, error);
                    }
                }
            }

            dayEl.appendChild(eventsEl);

            // Aplicar el nuevo estilo de visualización
            const shifts = events
                .filter(event => event.type !== 'note' && event.type !== 'recurring')
                .map(e => normalizeShiftEvent(e));
            if (shifts.length > 0) {
                // Si tiene turnos, asegurar que no esté atenuado como "otro mes"
                if (dayEl.classList.contains('other-month')) {
                    dayEl.classList.remove('other-month');
                    dayEl.style.opacity = '1';
                }

                if (shifts.length === 1) {
                    // Un solo turno: pintar toda la celda
                    const template = getTemplateForEvent(shifts[0]);
                    const color = template ? (template.backgroundColor || template.colorHex || template.color) :
                        (shifts[0].backgroundColor || shifts[0].colorHex || shifts[0].color || shifts[0].userColor || getUserColor(shifts[0].userId));

                    dayEl.style.backgroundColor = color;

                    // Ajustar número: sin fondo, alto contraste con el fondo del turno
                    numberEl.style.backgroundColor = 'transparent';
                    numberEl.style.padding = '0';
                    numberEl.style.borderRadius = '0';
                    numberEl.style.color = getContrastColor(color);
                    numberEl.style.textShadow = '0 1px 2px rgba(0,0,0,0.35)';

                    const shiftText = document.createElement('div');
                    shiftText.className = 'shift-text-full';
                    shiftText.textContent = template ? (template.abbreviation || template.name) : shifts[0].text;
                    const fontSize = getShiftFontSize(template, 13);
                    shiftText.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    dayEl.appendChild(shiftText);

                } else if (shifts.length === 2) {
                    // Dos turnos: dividir la celda en dos
                    const shift1 = shifts[0];
                    const shift2 = shifts[1];

                    const template1 = getTemplateForEvent(shift1);
                    const template2 = getTemplateForEvent(shift2);

                    const color1 = template1 ? (template1.backgroundColor || template1.colorHex || template1.color) :
                        (shift1.backgroundColor || shift1.colorHex || shift1.color || shift1.userColor || getUserColor(shift1.userId));
                    const color2 = template2 ? (template2.backgroundColor || template2.colorHex || template2.color) :
                        (shift2.backgroundColor || shift2.colorHex || shift2.color || shift2.userColor || getUserColor(shift2.userId));

                    dayEl.style.background = `linear-gradient(to bottom, ${color1} 50%, ${color2} 50%)`;

                    // En gradiente: usar blanco con sombra para legibilidad
                    numberEl.style.backgroundColor = 'transparent';
                    numberEl.style.padding = '0';
                    numberEl.style.borderRadius = '0';
                    numberEl.style.color = '#ffffff';
                    numberEl.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';

                    const text1 = document.createElement('div');
                    text1.className = 'shift-text-half';
                    text1.textContent = template1 ? (template1.abbreviation || template1.name) : shift1.text;
                    const fontSize1 = getShiftFontSize(template1, 12);
                    text1.style.cssText = `
                        position: absolute;
                        top: 25%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize1}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    dayEl.appendChild(text1);

                    const text2 = document.createElement('div');
                    text2.className = 'shift-text-half';
                    text2.textContent = template2 ? (template2.abbreviation || template2.name) : shift2.text;
                    const fontSize2 = getShiftFontSize(template2, 12);
                    text2.style.cssText = `
                        position: absolute;
                        top: 75%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        color: white;
                        font-weight: 700;
                        font-size: ${fontSize2}px;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    dayEl.appendChild(text2);

                } else if (shifts.length === 3) {
                    // Tres turnos: dividir en tres bandas
                    const [s1, s2, s3] = shifts;
                    const t1 = getTemplateForEvent(s1);
                    const t2 = getTemplateForEvent(s2);
                    const t3 = getTemplateForEvent(s3);
                    const c1 = t1 ? (t1.backgroundColor || t1.colorHex || t1.color) : (s1.userColor || getUserColor(s1.userId));
                    const c2 = t2 ? (t2.backgroundColor || t2.colorHex || t2.color) : (s2.userColor || getUserColor(s2.userId));
                    const c3 = t3 ? (t3.backgroundColor || t3.colorHex || t3.color) : (s3.userColor || getUserColor(s3.userId));

                    dayEl.style.background = `linear-gradient(to bottom, ${c1} 33.333%, ${c2} 33.333% 66.666%, ${c3} 66.666%)`;

                    // Número del día sin fondo, con sombra para contraste
                    numberEl.style.backgroundColor = 'transparent';
                    numberEl.style.padding = '0';
                    numberEl.style.borderRadius = '0';
                    numberEl.style.color = '#ffffff';
                    numberEl.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';

                    const mk = (txt, top, tmpl) => {
                        const el = document.createElement('div');
                        el.className = 'shift-text-third';
                        el.textContent = txt;
                        const fontSize = getShiftFontSize(tmpl, 11);
                        el.style.cssText = `position:absolute; top:${top}%; left:50%; transform:translate(-50%,-50%); color:white; font-weight:700; font-size:${fontSize}px; white-space:nowrap; z-index:10;`;
                        dayEl.appendChild(el);
                    };
                    mk(t1 ? (t1.abbreviation || t1.name) : s1.text, 16.5, t1);
                    mk(t2 ? (t2.abbreviation || t2.name) : s2.text, 50, t2);
                    mk(t3 ? (t3.abbreviation || t3.name) : s3.text, 83.5, t3);

                } else {
                    // Más de tres turnos: mostrar los primeros tres como badges
                    shifts.slice(0, 3).forEach((event, index) => {
                        const template = getTemplateForEvent(event);
                        const color = template ? (template.backgroundColor || template.colorHex || template.color) :
                            (event.userColor || getUserColor(event.userId));

                        const eventEl = document.createElement('div');
                        eventEl.className = 'event-badge';
                        const fontSize = getShiftFontSize(template, 10);
                        eventEl.style.cssText = `
                            position: absolute;
                            top: ${20 + index * 30}%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background-color: ${color};
                            color: ${getContrastColorInline(color)};
                            padding: 2px 6px;
                            border-radius: 4px;
                            font-size: ${fontSize}px;
                            font-weight: 600;
                            z-index: 10;
                        `;
                        eventEl.textContent = template ? (template.abbreviation || template.name) : event.text;
                        dayEl.appendChild(eventEl);
                    });
                }
            }

            // Asegurar que el día de hoy se vea con círculo, sin importar el fondo de turnos
            const todayCheck = new Date();
            if (date.toDateString() === todayCheck.toDateString()) {
                numberEl.style.backgroundColor = '#FF1744';
                numberEl.style.color = '#FFFFFF';
                numberEl.style.borderRadius = '50%';
                numberEl.style.padding = '2px 6px';
                numberEl.style.textShadow = 'none';
            }

            // Agregar texto de nota e iconos de categorías
            // Obtener todas las notas y eventos recurrentes (múltiples usuarios pueden tener notas)
            const notes = events.filter(event => event.type === 'note' || event.type === 'recurring');

            if (notes.length > 0) {
                // Si hay al menos una nota con texto o evento recurrente con título, ocultar los textos de los turnos para evitar superposición
                const hasAnyNoteText = notes.some(note =>
                    (note.text && note.text.trim() !== '') ||
                    (note.type === 'recurring' && note.title)
                );
                if (hasAnyNoteText) {
                    const shiftTexts = dayEl.querySelectorAll('.shift-text-full, .shift-text-half, .shift-text-third, .event-badge');
                    shiftTexts.forEach(el => el.style.display = 'none');
                }

                // Crear un contenedor para todas las notas
                const allNotesContainer = document.createElement('div');
                allNotesContainer.style.cssText = `
                    position: absolute;
                    top: 20px;
                    left: 2px;
                    right: 2px;
                    display: flex;
                    flex-direction: column;
                    gap: 2px;
                    z-index: 15;
                `;

                // Renderizar cada nota o evento recurrente
                notes.forEach(note => {
                    // Filtrar notas privadas y visibilidad
                    if (note.type === 'note') {
                        // Si es privada, solo mostrar al autor
                        if (note.private && note.userId !== currentUserId) {
                            return; // Omitir notas privadas que no son del usuario actual
                        }
                        // Si tiene lista de usuarios visibles, verificar si el usuario actual está incluido
                        if (note.visibleTo && Array.isArray(note.visibleTo)) {
                            if (!note.visibleTo.includes(currentUserId)) {
                                return; // Omitir si no está en la lista de visibles
                            }
                        } else if (!note.private) {
                            // Si no tiene lista visibleTo y no es privada, no mostrar a nadie (excepto al autor)
                            // Esto asegura que solo los usuarios explícitamente seleccionados puedan ver la nota
                            if (note.userId !== currentUserId) {
                                return; // Omitir si no es el autor y no tiene visibleTo
                            }
                        }
                    }

                    if (note.type === 'recurring' && note.title) {
                        // Renderizar evento recurrente
                        const lineUserColor = getUserColor(note.userId);
                        const noteTextEl = document.createElement('div');
                        noteTextEl.className = 'note-text';

                        noteTextEl.textContent = note.title;
                        const noteFontSize = 11;
                        noteTextEl.style.cssText = `
                            color: ${lineUserColor};
                        font-weight: 700;
                        font-size: ${noteFontSize}px;
                            text-decoration: underline;
                            white-space: normal;
                            word-wrap: break-word;
                            overflow-wrap: break-word;
                        `;
                        allNotesContainer.appendChild(noteTextEl);
                    } else if (note.text && note.text.trim() !== '') {
                        // Dividir el texto por saltos de línea para renderizar cada línea con su color
                        const noteLines = note.text.split('\n').filter(line => line.trim() !== '');

                        noteLines.forEach((line, index) => {
                            // Usar el color del usuario que creó la nota (ya no necesitamos heurística por contenido)
                            const lineUserColor = getUserColor(note.userId);
                            const noteTextEl = document.createElement('div');
                            noteTextEl.className = 'note-text';

                            // Agregar hora a la primera línea si existe
                            let displayText = line;
                            if (index === 0 && note.time) {
                                displayText = `${line} ${note.time}`;
                            }

                            noteTextEl.textContent = displayText;
                            // Usar el tamaño guardado en la nota o el por defecto
                            const noteFontSize = note.textSize || 11;
                            const fontSize = index === 0 ? noteFontSize : noteFontSize * 0.85;
                            const fontWeight = index === 0 ? '700' : 'normal';
                            noteTextEl.style.cssText = `
                                color: ${lineUserColor};
                                font-weight: ${fontWeight};
                                font-size: ${fontSize}px;
                                white-space: normal;
                                word-wrap: break-word;
                                overflow-wrap: break-word;
                            `;
                            allNotesContainer.appendChild(noteTextEl);
                        });
                    }
                });

                if (allNotesContainer.children.length > 0) {
                    dayEl.appendChild(allNotesContainer);
                }

                // Agregar iconos de categoría de todas las notas
                const allCategoriesEl = document.createElement('div');
                allCategoriesEl.className = 'category-icons';

                notes.forEach(note => {
                    if (note.categories && note.categories.length > 0) {
                        note.categories.forEach(category => {
                            if (category.icon && category.icon.trim() !== '') {
                                const iconEl = document.createElement('span');
                                iconEl.className = 'category-icon';
                                iconEl.textContent = category.icon;
                                iconEl.title = category.text;
                                // Aplicar el color del usuario que creó la nota al icono
                                const noteUserColor = getUserColor(note.userId);
                                iconEl.style.color = noteUserColor;
                                iconEl.style.borderColor = noteUserColor;
                                allCategoriesEl.appendChild(iconEl);
                            }
                        });
                    }
                });

                if (allCategoriesEl.children.length > 0) {
                    dayEl.appendChild(allCategoriesEl);
                }
            }

            // Click para abrir modal (solo si no estamos en modo pintura o borrar)
            dayEl.addEventListener('click', (e) => {
                if (!selectedShiftForPainting && !isDeleteMode) {
                    openDayModal(date);
                }
            });

            container.appendChild(dayEl);
        }

        // Cargar solo las DEFINICIONES de eventos recurrentes (sin generar ocurrencias)
        async function loadRecurringEvents() {
            if (!isFirebaseConnected) return;

            try {
                const snapshot = await db.collection('recurring_events').get();
                recurringEventsDefinitions = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));

                if (recurringEventsDefinitions.length === 0) {
                    console.log('📭 No hay eventos recurrentes configurados');
                } else {
                    console.log('✅', recurringEventsDefinitions.length, 'definiciones de eventos recurrentes cargadas');
                    recurringEventsDefinitions.forEach(e => {
                        const rawDate = e.startDate?.toDate ? e.startDate.toDate() : null;
                        const isoDate = rawDate ? rawDate.toISOString().split('T')[0] : 'N/A';
                        console.log('  -', e.title, '(', e.recurrenceType, ')',
                            'startDate:', isoDate);
                    });
                }

                // No generar ocurrencias, solo cargar las definiciones
                // Las ocurrencias se calcularán dinámicamente en getEventsForDate
                scheduleRenderCalendar();
            } catch (error) {
                console.error('❌ Error cargando eventos recurrentes:', error);
                // Si hay error (quota exceeded, etc.), desactivar Firebase
                if (error.message && error.message.includes('quota')) {
                    console.error('⚠️ Cuota de Firebase excedida, desactivando Firebase para esta sesión');
                    isFirebaseConnected = false;
                }
            }
        }

        // Obtener eventos para una fecha
        async function getEventsForDate(date) {
            const dateKey = formatDateKey(date);

            // Primero intentar desde la caché
            if (eventsCache.events && eventsCache.events[dateKey]) {
                let cachedEvents = eventsCache.events[dateKey];
                // Agregar eventos recurrentes calculados dinámicamente
                cachedEvents = await addRecurringEventsToDay(cachedEvents, date);
                return cachedEvents;
            }

            let events = [];
            if (isFirebaseConnected) {
                try {
                    const docRef = db.collection('calendar_events').doc(dateKey);
                    const doc = await docRef.get();

                    if (doc.exists) {
                        events = doc.data().events || [];
                    }
                } catch (error) {
                    console.error('❌ Error obteniendo eventos de Firestore:', error);
                    events = getEventsFromLocalStorage(date);
                }
            } else {
                events = getEventsFromLocalStorage(date);
            }

            // Agregar eventos recurrentes calculados dinámicamente
            events = await addRecurringEventsToDay(events, date);

            // NO guardar en caché eventos con recurrentes (se calculan dinámicamente)
            // La caché solo contiene eventos de Firebase sin recurrentes

            return events;
        }

        // Agregar eventos recurrentes calculados para un día específico
        async function addRecurringEventsToDay(events, date) {
            if (!recurringEventsDefinitions || recurringEventsDefinitions.length === 0) {
                return events;
            }

            const resultEvents = [...events];

            for (const eventDef of recurringEventsDefinitions) {
                try {
                    // Verificar si este evento recurrente tiene una ocurrencia en esta fecha
                    const hasOccurrence = checkIfDateMatchesRecurring(eventDef, date);

                    if (hasOccurrence) {
                        // Verificar si ya existe en eventos
                        const exists = resultEvents.some(e =>
                            e.type === 'recurring' && e.recurringEventId === eventDef.id
                        );

                        if (!exists) {
                            resultEvents.push({
                                type: 'recurring',
                                recurringEventId: eventDef.id,
                                title: eventDef.title,
                                description: eventDef.description || '',
                                time: eventDef.time,
                                userId: currentUserId,
                                userColor: getUserColor(currentUserId),
                                createdAt: new Date().toISOString()
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error verificando evento recurrente:', eventDef.title, error);
                }
            }

            return resultEvents;
        }

        // Verificar si una fecha coincide con una regla de evento recurrente
        function checkIfDateMatchesRecurring(eventDef, date) {
            // Normalizar fechas para comparación
            const dateNormalized = new Date(date);
            dateNormalized.setHours(0, 0, 0, 0);

            let eventStart;
            if (eventDef.startDate && eventDef.startDate.toDate) {
                const firestoreDate = eventDef.startDate.toDate();
                // Convertir a string ISO sin zona horaria para evitar problemas
                const dateStr = firestoreDate.toISOString().split('T')[0];
                eventStart = new Date(dateStr);
            } else if (eventDef.startDate instanceof Date) {
                eventStart = new Date(eventDef.startDate);
            } else {
                console.error('Formato de startDate inválido:', eventDef.startDate);
                return false;
            }
            eventStart.setHours(0, 0, 0, 0);

            // Log removed to avoid quota exhaustion

            // Si la fecha está antes del inicio, no coincide
            if (dateNormalized < eventStart) {
                return false;
            }

            // Si hay fecha de fin, verificar
            if (eventDef.endDate) {
                let eventEnd;
                if (eventDef.endDate.toDate) {
                    const firestoreEndDate = eventDef.endDate.toDate();
                    const dateStr = firestoreEndDate.toISOString().split('T')[0];
                    eventEnd = new Date(dateStr);
                } else if (eventDef.endDate instanceof Date) {
                    eventEnd = new Date(eventDef.endDate);
                } else {
                    eventEnd = new Date(eventDef.endDate);
                }
                eventEnd.setHours(23, 59, 59, 999);
                if (dateNormalized > eventEnd) {
                    return false;
                }
            }

            // Calcular el número de días desde el inicio
            const daysSinceStart = Math.floor((dateNormalized - eventStart) / (1000 * 60 * 60 * 24));

            switch (eventDef.recurrenceType) {
                case 'daily':
                    return true; // Todos los días

                case 'weekly':
                    return daysSinceStart % 7 === 0;

                case 'monthly':
                    // Verificar si el día del mes coincide
                    return dateNormalized.getDate() === eventStart.getDate();

                case 'yearly':
                    // Verificar si el día y mes coinciden
                    const matches = dateNormalized.getMonth() === eventStart.getMonth() &&
                        dateNormalized.getDate() === eventStart.getDate();
                    return matches;

                case 'custom':
                    // Verificar intervalos personalizados
                    const interval = eventDef.customInterval || 1;
                    const unit = eventDef.customUnit || 'days';

                    let shouldMatch = false;
                    if (unit === 'days') {
                        shouldMatch = daysSinceStart % interval === 0;
                    } else if (unit === 'weeks') {
                        shouldMatch = daysSinceStart % (interval * 7) === 0;
                    } else if (unit === 'months') {
                        // Calcular diferencia de meses
                        const monthDiff = (date.getFullYear() - eventStart.getFullYear()) * 12 +
                            (date.getMonth() - eventStart.getMonth());
                        shouldMatch = monthDiff % interval === 0;
                    }

                    // Si hay días específicos de la semana, verificar
                    if (shouldMatch && eventDef.customDaysOfWeek && eventDef.customDaysOfWeek.length > 0) {
                        const dayOfWeek = date.getDay();
                        shouldMatch = eventDef.customDaysOfWeek.includes(dayOfWeek);
                    }

                    return shouldMatch;

                default:
                    return false;
            }
        }

        // Fallback: obtener eventos de localStorage
        function getEventsFromLocalStorage(date) {
            const dateKey = formatDateKey(date);
            const eventsJson = localStorage.getItem('calendar_events');
            const allEvents = eventsJson ? JSON.parse(eventsJson) : {};
            return allEvents[dateKey] || [];
        }

        // Obtener eventos sincrónicamente desde caché precargada o localStorage (sin esperas)
        // NOTA: Esta función ya no incluye eventos recurrentes, usar getEventsForDate para obtener todos los eventos
        function getEventsForDateCached(date) {
            const dateKey = formatDateKey(date);
            if (eventsCache.events && eventsCache.events[dateKey]) {
                return eventsCache.events[dateKey];
            }
            return getEventsFromLocalStorage(date);
        }

        // Guardar eventos
        async function saveEvents(date, events) {
            const dateKey = formatDateKey(date);

            // Filtrar eventos recurrentes antes de guardar (no se guardan en Firebase)
            const eventsToSave = events.filter(e => e.type !== 'recurring');

            if (isFirebaseConnected) {
                try {
                    await db.collection('calendar_events').doc(dateKey).set({
                        events: eventsToSave,
                        lastModified: firebase.firestore.FieldValue.serverTimestamp(),
                        modifiedBy: currentUserId
                    });
                    console.log('✅ Eventos guardados en Firestore');
                    // Limpiar caché para forzar recarga desde Firebase
                    if (eventsCache.events) {
                        delete eventsCache.events[dateKey];
                    }
                } catch (error) {
                    console.error('❌ Error guardando en Firestore:', error);
                    // Fallback a localStorage
                    saveEventsToLocalStorage(date, eventsToSave);
                }
            } else {
                saveEventsToLocalStorage(date, eventsToSave);
            }
        }

        // Fallback: guardar eventos en localStorage
        function saveEventsToLocalStorage(date, events) {
            const dateKey = formatDateKey(date);
            const eventsJson = localStorage.getItem('calendar_events');
            const allEvents = eventsJson ? JSON.parse(eventsJson) : {};
            allEvents[dateKey] = events;
            localStorage.setItem('calendar_events', JSON.stringify(allEvents));
            console.log('💾 Eventos guardados en localStorage');
        }

        // Formatear fecha como clave
        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Formatear fecha para mostrar
        function formatDateDisplay(date) {
            const day = date.getDate();
            const month = monthNames[date.getMonth()];
            const year = date.getFullYear();
            return `${day} de ${month} de ${year}`;
        }

        // Obtener color de usuario
        function getUserColor(userId) {
            const user = users.find(u => u.id === userId);
            return user ? user.color : '#999';
        }

        // Obtener nombre de usuario
        function getUserName(userId) {
            const user = users.find(u => u.id === userId);
            return user ? user.name : 'Usuario';
        }

        // Obtener plantilla de turno a partir de un evento (prioriza shiftId, luego nombre/abreviatura)
        function getTemplateForEvent(event) {
            if (!event) return null;
            if (event.shiftId) {
                const byId = shiftTemplates.find(t => t.id === event.shiftId);
                if (byId) return byId;
            }
            const text = (event.text || '').toString().trim().toLowerCase();
            if (!text) return null;
            return shiftTemplates.find(t => {
                const n = (t.name || '').toString().trim().toLowerCase();
                const a = (t.abbreviation || '').toString().trim().toLowerCase();
                return n === text || a === text;
            }) || null;
        }

        // Obtener el tamaño de fuente del template del turno, con valor por defecto
        function getShiftFontSize(template, defaultSize = 13) {
            if (!template) return defaultSize;
            return template.textSize || defaultSize;
        }

        // Normaliza un evento de turno a referencia canónica: asegura shiftId y texto estándar
        function normalizeShiftEvent(event) {
            if (!event) return event;
            const tmpl = getTemplateForEvent(event);
            if (tmpl) {
                // Asegurar id y texto consistente
                event.shiftId = tmpl.id;
                event.text = tmpl.abbreviation || tmpl.name || event.text;
                // Asegurar color para fallback
                event.userColor = event.userColor || tmpl.backgroundColor || tmpl.colorHex || tmpl.color;
            }
            return event;
        }

        // Utilidades de color
        function normalizeHex(color) {
            if (!color) return null;
            let c = color.trim();
            if (c.startsWith('rgb')) {
                // rgb/rgba -> hex aproximado
                const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
                if (m) {
                    const r = parseInt(m[1], 10), g = parseInt(m[2], 10), b = parseInt(m[3], 10);
                    return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
                }
            }
            if (c.startsWith('#') && c.length === 4) {
                // #RGB -> #RRGGBB
                c = '#' + c[1] + c[1] + c[2] + c[2] + c[3] + c[3];
            }
            if (!c.startsWith('#')) return c.toUpperCase();
            return c.toUpperCase();
        }

        function hexToRgb(hex) {
            const c = normalizeHex(hex);
            if (!c || !c.startsWith('#') || (c.length !== 7)) return null;
            return {
                r: parseInt(c.slice(1, 3), 16),
                g: parseInt(c.slice(3, 5), 16),
                b: parseInt(c.slice(5, 7), 16)
            };
        }

        function getLuminance(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return 0.5;
            const srgb = [rgb.r / 255, rgb.g / 255, rgb.b / 255].map(v => {
                return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
            });
            return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
        }

        function getContrastColor(hex) {
            const c = normalizeHex(hex);
            const lum = getLuminance(c);
            return lum > 0.5 ? '#000000' : '#FFFFFF';
        }

        function getContrastColorInline(hex) {
            // Helper para CSS inline cuando hay gradientes/badges
            try { return getContrastColor(hex); } catch (e) { return '#FFFFFF'; }
        }

        function colorsEqual(a, b) {
            return normalizeHex(a) === normalizeHex(b);
        }

        function resolveNoteColor(userColor, shifts) {
            // Si el color de la nota (usuario) coincide con alguno de los colores de turno del día,
            // usar un color con alto contraste para que se lea.
            const uc = normalizeHex(userColor);
            const shiftColors = (shifts || []).map(s => {
                const t = shiftTemplates.find(t => t.name === s.text || t.abbreviation === s.text);
                return normalizeHex(t ? (t.backgroundColor || t.colorHex || t.color) : (s.userColor || getUserColor(s.userId)));
            }).filter(Boolean);
            const conflict = shiftColors.some(c => c === uc);
            if (conflict) {
                // Elegir blanco o negro según luminancia de ese color
                return getContrastColor(uc);
            }
            return userColor;
        }

        // Cambiar mes
        function changeMonth(delta) {
            currentDate.setMonth(currentDate.getMonth() + delta);
            renderCalendar(true); // Forzar render inmediato para cambio de mes
        }

        // Estado de año para vista anual
        let yearViewYear = null;
        function changeYear(delta) {
            if (yearViewYear == null) yearViewYear = currentDate.getFullYear();
            yearViewYear += delta;
            updateYearNav();
            renderYear();
            // Actualiza el texto del botón de pestaña del año si coincide con formato YYYY
            const yearTabBtn = Array.from(document.querySelectorAll('.tab-btn')).find(b => b.textContent.trim().match(/^\d{4}$/));
            if (yearTabBtn) yearTabBtn.textContent = String(yearViewYear);
        }

        function updateYearNav() {
            const title = document.getElementById('yearTitle');
            const yr = yearViewYear ?? currentUserYear();
            if (title) title.textContent = String(yr);
        }

        function currentUserYear() { return currentDate.getFullYear(); }

        // Renderizar vista anual rápida usando caché/localStorage
        async function renderYear() {
            const grid = document.getElementById('yearGrid');
            if (!grid) return;
            grid.innerHTML = '';

            const baseYear = yearViewYear ?? currentDate.getFullYear();
            for (let m = 0; m < 12; m++) {
                const monthBox = document.createElement('div');
                monthBox.className = 'year-month';
                monthBox.dataset.month = String(m);
                monthBox.dataset.year = String(baseYear);

                const header = document.createElement('div');
                header.className = 'year-month-header';
                header.textContent = monthNames[m].toUpperCase();
                monthBox.appendChild(header);

                const monthGrid = document.createElement('div');
                monthGrid.className = 'year-month-grid';

                // Encabezados de semana
                ['L', 'M', 'X', 'J', 'V', 'S', 'D'].forEach(w => {
                    const wEl = document.createElement('div');
                    wEl.className = 'year-weekday';
                    wEl.textContent = w;
                    monthGrid.appendChild(wEl);
                });

                const firstDay = new Date(baseYear, m, 1);
                const lastDay = new Date(baseYear, m + 1, 0);
                const daysInMonth = lastDay.getDate();
                const startDayOfWeek = firstDay.getDay();
                const adjustedStart = startDayOfWeek === 0 ? 6 : startDayOfWeek - 1;

                // Relleno inicial
                for (let i = 0; i < adjustedStart; i++) {
                    const dEl = document.createElement('div');
                    dEl.className = 'year-day other-month';
                    monthGrid.appendChild(dEl);
                }

                for (let d = 1; d <= daysInMonth; d++) {
                    const date = new Date(baseYear, m, d);
                    const dayEl = document.createElement('div');
                    dayEl.className = 'year-day';

                    const num = document.createElement('div');
                    num.className = 'year-day-number';
                    num.textContent = d;
                    dayEl.appendChild(num);

                    // Garantía de datos: usa caché si existe; si no, consulta inmediata
                    let events = getEventsForDateCached(date);
                    if (!events || events.length === 0) {
                        events = await getEventsForDate(date);
                    }
                    const shifts = events.filter(e => e.type !== 'note');
                    if (shifts.length > 0) {
                        if (shifts.length === 1) {
                            const ev = shifts[0];
                            const template = shiftTemplates.find(t => t.name === ev.text || t.abbreviation === ev.text);
                            const color = template ? (template.backgroundColor || template.colorHex || template.color) : (ev.userColor || getUserColor(ev.userId));
                            dayEl.style.background = color;
                            num.style.color = getContrastColor(color);
                            num.style.textShadow = '0 1px 2px rgba(0,0,0,0.35)';
                        } else if (shifts.length === 2) {
                            const s1 = shifts[0], s2 = shifts[1];
                            const t1 = shiftTemplates.find(t => t.name === s1.text || t.abbreviation === s1.text);
                            const t2 = shiftTemplates.find(t => t.name === s2.text || t.abbreviation === s2.text);
                            const c1 = t1 ? (t1.backgroundColor || t1.colorHex || t1.color) : (s1.userColor || getUserColor(s1.userId));
                            const c2 = t2 ? (t2.backgroundColor || t2.colorHex || t2.color) : (s2.userColor || getUserColor(s2.userId));
                            dayEl.style.background = `linear-gradient(to bottom, ${c1} 50%, ${c2} 50%)`;
                            num.style.color = '#FFFFFF';
                            num.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';
                        } else {
                            const s1 = shifts[0], s2 = shifts[1], s3 = shifts[2];
                            const t1 = shiftTemplates.find(t => t.name === s1.text || t.abbreviation === s1.text);
                            const t2 = shiftTemplates.find(t => t.name === s2.text || t.abbreviation === s2.text);
                            const t3 = shiftTemplates.find(t => t.name === s3.text || t.abbreviation === s3.text);
                            const c1 = t1 ? (t1.backgroundColor || t1.colorHex || t1.color) : (s1.userColor || getUserColor(s1.userId));
                            const c2 = t2 ? (t2.backgroundColor || t2.colorHex || t2.color) : (s2.userColor || getUserColor(s2.userId));
                            const c3 = t3 ? (t3.backgroundColor || t3.colorHex || t3.color) : (s3.userColor || getUserColor(s3.userId));
                            dayEl.style.background = `linear-gradient(to bottom, ${c1} 33.34%, ${c2} 33.34%, ${c2} 66.66%, ${c3} 66.66%)`;
                            num.style.color = '#FFFFFF';
                            num.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';
                        }
                    }

                    const today = new Date();
                    if (date.toDateString() === today.toDateString()) {
                        num.style.backgroundColor = '#FF1744';
                        num.style.color = '#fff';
                        num.style.borderRadius = '50%';
                        num.style.padding = '1px 4px';
                        num.style.textShadow = 'none';
                    }

                    monthGrid.appendChild(dayEl);
                }

                // Completar el final hasta múltiplo de 7
                const used = adjustedStart + daysInMonth;
                const rest = (7 - (used % 7)) % 7;
                for (let i = 0; i < rest; i++) {
                    const dEl = document.createElement('div');
                    dEl.className = 'year-day other-month';
                    monthGrid.appendChild(dEl);
                }

                monthBox.appendChild(monthGrid);
                // Evitar duplicados: reemplazar si ya existe un mes con mismo índice
                const existing = grid.querySelector(`.year-month[data-year="${baseYear}"][data-month="${m}"]`);
                if (existing) {
                    grid.replaceChild(monthBox, existing);
                } else {
                    grid.appendChild(monthBox);
                }
            }
        }



        // Abrir modal de día
        async function openDayModal(date) {
            selectedDate = date;

            // Actualizar fecha en formato D/M/YY
            const day = date.getDate();
            const month = date.getMonth() + 1;
            const year = date.getFullYear().toString().slice(-2);
            document.getElementById('modalDate').textContent = `${day}/${month}/${year}`;

            // Cargar notas existentes del día
            await loadDayNotes(date);

            // Cargar y mostrar turnos del día
            await loadDayShifts(date);

            // Cargar alarmas y actualizar contador
            await loadAlarms();

            document.getElementById('dayModal').classList.add('show');
        }

        // Cargar notas del día desde Firebase
        async function loadDayNotes(date) {
            try {
                // Obtener eventos del día
                const events = await getEventsForDate(date);

                // Buscar la nota del usuario actual (cada usuario tiene su propia nota)
                const note = events.find(event => event.type === 'note' && event.userId === currentUserId);

                if (note) {
                    // Mostrar la nota en el textarea
                    document.getElementById('mainTextarea').value = note.text;

                    // Cargar categorías si existen
                    if (note.categories && note.categories.length > 0) {
                        loadCategories(note.categories);
                    } else {
                        resetCategories();
                    }

                    console.log('✅ Nota del usuario actual cargada para el día:', note.text);
                } else {
                    // Limpiar textarea si no hay nota
                    document.getElementById('mainTextarea').value = '';
                    resetCategories();
                    console.log('ℹ️ No hay nota del usuario actual para este día');
                }

            } catch (error) {
                console.error('❌ Error cargando notas del día:', error);
                document.getElementById('mainTextarea').value = '';
                resetCategories();
            }
        }

        // Cargar categorías en los dropdowns
        function loadCategories(categories) {
            for (let i = 0; i < 3; i++) {
                if (i < categories.length) {
                    const category = categories[i];
                    const dropdown = document.getElementById(`dropdown-${i}`);
                    if (dropdown) {
                        const iconElement = dropdown.querySelector('.no-icon');
                        const textElement = dropdown.querySelector('.dropdown-text');
                        if (iconElement && textElement) {
                            iconElement.textContent = category.icon;
                            textElement.textContent = category.text;
                        }
                    }
                } else {
                    resetCategory(i);
                }
            }
        }

        // Resetear categorías
        function resetCategories() {
            for (let i = 0; i < 3; i++) {
                resetCategory(i);
            }
        }

        // Resetear una categoría específica
        function resetCategory(index) {
            const dropdown = document.getElementById(`dropdown-${index}`);
            if (dropdown) {
                const iconElement = dropdown.querySelector('.no-icon');
                const textElement = dropdown.querySelector('.dropdown-text');
                if (iconElement && textElement) {
                    iconElement.textContent = '🚫';
                    textElement.textContent = 'Ninguno';
                }
            }
        }

        // Cargar turnos del día desde Firebase
        async function loadDayShifts(date) {
            const shiftsContent = document.getElementById('shiftsContent');

            try {
                // Obtener eventos del día
                const events = await getEventsForDate(date);

                // Filtrar solo turnos (excluir notas y eventos recurrentes)
                const shifts = events.filter(event =>
                    event.type !== 'note' &&
                    event.type !== 'recurring' &&
                    event.text &&
                    event.text !== 'undefined'
                );

                if (shifts.length === 0) {
                    shiftsContent.innerHTML = `
                        <div class="clock-icon">🕐</div>
                        <div class="no-shifts-text">No hay turnos asignados</div>
                    `;
                    return;
                }

                // Limpiar contenido
                shiftsContent.innerHTML = '';

                // Mostrar cada turno
                shifts.forEach(shift => {
                    const shiftItem = document.createElement('div');
                    shiftItem.className = 'shift-item';

                    // Buscar el shift template correspondiente
                    const template = shiftTemplates.find(t => t.name === shift.text || t.abbreviation === shift.text);

                    if (template) {
                        shiftItem.innerHTML = `
                            <div class="shift-circle" style="background-color: ${template.colorHex}"></div>
                            <div class="shift-name">${template.name}</div>
                        `;
                    } else {
                        // Fallback si no se encuentra template
                        shiftItem.innerHTML = `
                            <div class="shift-circle"></div>
                            <div class="shift-name">${shift.text}</div>
                        `;
                    }

                    shiftsContent.appendChild(shiftItem);
                });

                console.log('✅ Turnos cargados para el día:', shifts.length);

            } catch (error) {
                console.error('❌ Error cargando turnos del día:', error);
                shiftsContent.innerHTML = `
                    <div class="clock-icon">🕐</div>
                    <div class="no-shifts-text">Error cargando turnos</div>
                `;
            }
        }

        // Cerrar modal
        function closeModal() {
            document.getElementById('dayModal').classList.remove('show');
        }

        // Variables para el modal de notas
        let originalNoteText = '';
        let originalNoteTextSize = 11; // Tamaño por defecto
        let originalNoteTime = '';
        let originalNotePrivate = false; // Visibilidad por defecto
        let currentFormatState = {
            bold: false,
            italic: false,
            underline: false
        };

        // Abrir modal de notas
        async function openNotesPopup() {
            const textarea = document.getElementById('mainTextarea');
            originalNoteText = textarea.value || '';

            // Cargar el texto actual en el modal de notas
            const notesTextarea = document.getElementById('notesTextarea');
            // Si es contentEditable, usar innerHTML/textContent
            if (notesTextarea.contentEditable === 'true') {
                notesTextarea.innerHTML = originalNoteText.replace(/\n/g, '<br>');
                if (notesTextarea.innerHTML === '') {
                    notesTextarea.textContent = '';
                }
            } else {
                notesTextarea.value = originalNoteText;
            }

            // Cargar el tamaño de texto y hora guardados si existen
            if (selectedDate) {
                try {
                    const events = await getEventsForDate(selectedDate);
                    console.log('📋 Eventos cargados:', JSON.stringify(events));
                    // Buscar la nota del usuario actual
                    const note = events.find(event => event.type === 'note' && event.userId === currentUserId);
                    console.log('📝 Nota encontrada:', JSON.stringify(note));
                    if (note) {
                        if (note.textSize) {
                            originalNoteTextSize = parseInt(note.textSize) || 11;
                        } else {
                            originalNoteTextSize = 11; // Por defecto
                        }
                        if (note.time) {
                            originalNoteTime = note.time;
                            console.log('✅ Hora encontrada en nota:', note.time);
                        } else {
                            originalNoteTime = '';
                            console.log('⚠️ No hay hora en la nota');
                        }
                        if (note.private) {
                            originalNotePrivate = note.private;
                            console.log('✅ Privacidad encontrada en nota:', note.private);
                        } else {
                            originalNotePrivate = false;
                            console.log('⚠️ No hay privacidad en la nota');
                        }
                    } else {
                        originalNoteTextSize = 11;
                        originalNoteTime = '';
                        originalNotePrivate = false;
                        console.log('⚠️ No se encontró nota para el usuario');
                    }
                } catch (error) {
                    console.error('Error cargando datos de nota:', error);
                    originalNoteTextSize = 11;
                    originalNoteTime = '';
                    originalNotePrivate = false;
                }
            } else {
                originalNoteTextSize = 11;
                originalNoteTime = '';
                originalNotePrivate = false;
            }

            // Actualizar el slider y el valor mostrado
            const slider = document.getElementById('notesTextSizeSlider');
            const valueDisplay = document.getElementById('notesTextSizeValue');
            if (slider && valueDisplay) {
                slider.value = originalNoteTextSize;
                valueDisplay.textContent = originalNoteTextSize;
                console.log('📏 Tamaño de texto cargado:', originalNoteTextSize);
            }

            // Actualizar el campo de hora
            const timeInput = document.getElementById('notesTimeInput');
            if (timeInput) {
                timeInput.value = originalNoteTime;
                console.log('🕐 Hora cargada en input:', originalNoteTime);
            }

            // Actualizar el checkbox de privacidad y generar selector de usuarios
            const privateCheck = document.getElementById('notesPrivateCheck');
            if (privateCheck) {
                privateCheck.checked = originalNotePrivate;
                console.log('🔒 Privacidad cargada:', originalNotePrivate);

                // Generar checkboxes de usuarios
                const userSelectionDiv = document.getElementById('notesUserSelection');
                if (userSelectionDiv) {
                    userSelectionDiv.innerHTML = '';
                    users.forEach(user => {
                        if (user.id !== currentUserId) { // No mostrar el usuario actual
                            const checkboxDiv = document.createElement('div');
                            checkboxDiv.className = 'user-checkbox-item';
                            const checkboxId = `userCheck_${user.id}`;
                            checkboxDiv.innerHTML = `
                                <input type="checkbox" id="${checkboxId}" data-user-id="${user.id}">
                                <span class="user-color-dot" style="background-color: ${user.color};"></span>
                                <span>${user.name}</span>
                            `;
                            userSelectionDiv.appendChild(checkboxDiv);
                        }
                    });

                    // Mostrar/ocultar selector según si es privada
                    userSelectionDiv.style.display = originalNotePrivate ? 'none' : 'block';
                }

                // Event listener para toggle privacidad
                privateCheck.addEventListener('change', function () {
                    const userSelectionDiv = document.getElementById('notesUserSelection');
                    if (userSelectionDiv) {
                        userSelectionDiv.style.display = this.checked ? 'none' : 'block';
                    }
                });
            }

            // Cargar usuarios seleccionados si existe, o marcar todos por defecto
            if (selectedDate) {
                try {
                    const events = await getEventsForDate(selectedDate);
                    const note = events.find(event => event.type === 'note' && event.userId === currentUserId);
                    if (note && note.visibleTo && Array.isArray(note.visibleTo)) {
                        // Si hay una nota existente con usuarios seleccionados, cargar esos
                        note.visibleTo.forEach(userId => {
                            const checkbox = document.getElementById(`userCheck_${userId}`);
                            if (checkbox) {
                                checkbox.checked = true;
                            }
                        });
                    } else {
                        // Si no hay nota o no tiene visibleTo, marcar TODOS los usuarios por defecto
                        const userCheckboxes = document.querySelectorAll('#notesUserSelection input[type="checkbox"]');
                        userCheckboxes.forEach(checkbox => {
                            checkbox.checked = true;
                        });
                    }
                } catch (error) {
                    console.error('Error cargando usuarios seleccionados:', error);
                    // En caso de error, marcar todos por defecto
                    const userCheckboxes = document.querySelectorAll('#notesUserSelection input[type="checkbox"]');
                    userCheckboxes.forEach(checkbox => {
                        checkbox.checked = true;
                    });
                }
            } else {
                // Si no hay fecha seleccionada, marcar todos por defecto
                const userCheckboxes = document.querySelectorAll('#notesUserSelection input[type="checkbox"]');
                userCheckboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
            }

            // Resetear formato
            resetFormatButtons();

            // Mostrar el modal
            document.getElementById('notesModal').classList.add('show');

            // Agregar event listeners para actualizar botones de formato
            notesTextarea.addEventListener('mouseup', updateFormatButtons);
            notesTextarea.addEventListener('keyup', updateFormatButtons);
            notesTextarea.addEventListener('selectionchange', updateFormatButtons);

            // Enfocar el campo de texto
            setTimeout(() => {
                notesTextarea.focus();
            }, 100);
        }

        // Actualizar el tamaño de texto mostrado
        function updateNotesTextSize(value) {
            document.getElementById('notesTextSizeValue').textContent = value;
        }

        // Cerrar modal de notas sin guardar
        function cancelNotesPopup() {
            // Cerrar el modal sin guardar cambios
            document.getElementById('notesModal').classList.remove('show');
        }

        // Aceptar cambios del modal de notas
        async function acceptNotesPopup() {
            const notesTextarea = document.getElementById('notesTextarea');
            let newText = '';

            // Obtener el texto según el tipo de elemento
            if (notesTextarea.contentEditable === 'true') {
                // Para contentEditable, obtener texto sin HTML pero preservar saltos de línea
                newText = notesTextarea.innerText || notesTextarea.textContent || '';
            } else {
                newText = notesTextarea.value || '';
            }

            // Obtener el tamaño de texto y hora seleccionados
            const slider = document.getElementById('notesTextSizeSlider');
            const textSize = slider ? parseInt(slider.value) || 11 : 11;

            const timeInput = document.getElementById('notesTimeInput');
            const noteTime = timeInput ? timeInput.value.trim() : '';

            const privateCheck = document.getElementById('notesPrivateCheck');
            const notePrivate = privateCheck ? privateCheck.checked : false;

            // Obtener usuarios seleccionados (siempre incluir al autor)
            let visibleTo = null;
            if (!notePrivate) {
                visibleTo = [];
                // Agregar siempre al autor
                visibleTo.push(currentUserId);
                const userCheckboxes = document.querySelectorAll('#notesUserSelection input[type="checkbox"]');
                userCheckboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        visibleTo.push(parseInt(checkbox.dataset.userId));
                    }
                });
            }

            console.log('📏 Tamaño de texto seleccionado:', textSize);
            console.log('🕐 Hora seleccionada:', noteTime);
            console.log('🔒 Privacidad seleccionada:', notePrivate);
            console.log('👥 Usuarios seleccionados:', visibleTo);

            // Actualizar el textarea principal del modal de día
            document.getElementById('mainTextarea').value = newText.trim();

            // Guardar inmediatamente en Firebase si hay fecha seleccionada
            if (selectedDate) {
                try {
                    const existingEvents = await getEventsForDate(selectedDate);
                    // Buscar la nota del usuario actual (no la primera nota general)
                    const existingNoteIndex = existingEvents.findIndex(event => event.type === 'note' && event.userId === currentUserId);

                    console.log('📝 Nota existente del usuario actual encontrada:', existingNoteIndex !== -1);
                    if (existingNoteIndex !== -1) {
                        console.log('📝 Nota existente antes de actualizar:', JSON.stringify(existingEvents[existingNoteIndex]));
                    }

                    if (newText.trim() === '') {
                        // Si no hay texto, eliminar la nota existente del usuario actual
                        if (existingNoteIndex !== -1) {
                            existingEvents.splice(existingNoteIndex, 1);
                        }
                    } else {
                        const noteEvent = {
                            text: newText.trim(),
                            textSize: textSize, // Guardar el tamaño del texto
                            time: noteTime || undefined, // Guardar la hora si existe
                            private: notePrivate, // Guardar la privacidad
                            visibleTo: visibleTo, // Guardar usuarios seleccionados (null si es privada, array si es pública)
                            userId: currentUserId,
                            userColor: getUserColor(currentUserId),
                            createdAt: existingNoteIndex !== -1 ? existingEvents[existingNoteIndex].createdAt : new Date().toISOString(),
                            updatedAt: new Date().toISOString(),
                            categories: existingNoteIndex !== -1 && existingEvents[existingNoteIndex].categories ? existingEvents[existingNoteIndex].categories : [],
                            type: 'note'
                        };

                        console.log('💾 Nota a guardar:', JSON.stringify(noteEvent));

                        if (existingNoteIndex !== -1) {
                            existingEvents[existingNoteIndex] = noteEvent;
                            console.log('✏️ Nota del usuario actual actualizada en índice:', existingNoteIndex);
                        } else {
                            existingEvents.push(noteEvent);
                            console.log('📝 Nueva nota del usuario actual agregada');
                        }
                    }

                    await saveEvents(selectedDate, existingEvents);
                    console.log('✅ Nota guardada en Firebase con textSize:', textSize);

                    // Verificar que se guardó correctamente
                    const verifyEvents = await getEventsForDate(selectedDate);
                    const verifyNote = verifyEvents.find(event => event.type === 'note' && event.userId === currentUserId);
                    if (verifyNote) {
                        console.log('✅ Verificación: Nota del usuario actual guardada con textSize:', verifyNote.textSize);
                    } else {
                        console.warn('⚠️ Verificación: No se encontró la nota del usuario actual después de guardar');
                    }

                    // Refrescar el calendario para mostrar el nuevo tamaño
                    scheduleRenderCalendar();
                } catch (error) {
                    console.error('❌ Error guardando nota:', error);
                }
            }

            // Cerrar el modal
            document.getElementById('notesModal').classList.remove('show');
        }

        // Borrar nota (sin cerrar el pop-up)
        function deleteNote() {
            const notesTextarea = document.getElementById('notesTextarea');

            // Limpiar el contenido editable
            if (notesTextarea.contentEditable === 'true') {
                notesTextarea.innerHTML = '';
                notesTextarea.textContent = '';
            } else {
                notesTextarea.value = '';
            }

            // También actualizar el textarea principal (pero no cerrar el modal)
            document.getElementById('mainTextarea').value = '';

            // Resetear formato
            resetFormatButtons();

            // Enfocar el campo de texto
            notesTextarea.focus();
        }

        // Aplicar formato de texto (bold, italic, underline)
        function toggleFormat(format) {
            const notesTextarea = document.getElementById('notesTextarea');

            // Verificar que sea contentEditable
            if (notesTextarea.contentEditable !== 'true') {
                return;
            }

            // Asegurar que el elemento tenga foco
            notesTextarea.focus();

            // Usar document.execCommand para aplicar formato
            let command = '';
            switch (format) {
                case 'bold':
                    command = 'bold';
                    break;
                case 'italic':
                    command = 'italic';
                    break;
                case 'underline':
                    command = 'underline';
                    break;
            }

            if (command) {
                try {
                    document.execCommand(command, false, null);

                    // Actualizar el estado visual del botón
                    const btn = document.getElementById('format' + format.charAt(0).toUpperCase() + format.slice(1));
                    const isActive = document.queryCommandState(command);

                    btn.classList.toggle('active', isActive);
                    currentFormatState[format] = isActive;
                } catch (e) {
                    console.error('Error aplicando formato:', e);
                }
            }

            // Volver a enfocar el campo de texto
            notesTextarea.focus();
        }

        // Actualizar el estado de los botones de formato según la selección
        function updateFormatButtons() {
            const notesTextarea = document.getElementById('notesTextarea');
            if (notesTextarea.contentEditable !== 'true') return;

            // Verificar el estado de cada formato
            const boldActive = document.queryCommandState('bold');
            const italicActive = document.queryCommandState('italic');
            const underlineActive = document.queryCommandState('underline');

            // Actualizar los botones
            document.getElementById('formatBold').classList.toggle('active', boldActive);
            document.getElementById('formatItalic').classList.toggle('active', italicActive);
            document.getElementById('formatUnderline').classList.toggle('active', underlineActive);

            // Actualizar el estado
            currentFormatState.bold = boldActive;
            currentFormatState.italic = italicActive;
            currentFormatState.underline = underlineActive;
        }

        // Resetear botones de formato
        function resetFormatButtons() {
            document.getElementById('formatBold').classList.remove('active');
            document.getElementById('formatItalic').classList.remove('active');
            document.getElementById('formatUnderline').classList.remove('active');
            currentFormatState = {
                bold: false,
                italic: false,
                underline: false
            };
        }

        // Manejar clic fuera del modal para cerrarlo
        function handleNotesModalClick(event) {
            if (event.target.id === 'notesModal') {
                cancelNotesPopup();
            }
        }

        // Agregar listener para cambios de selección (para actualizar botones de formato)
        document.addEventListener('selectionchange', function () {
            const modal = document.getElementById('notesModal');
            if (modal && modal.classList.contains('show')) {
                updateFormatButtons();
            }
        });

        // Variables para alarmas
        let alarms = [];

        // Cargar alarmas desde Firebase
        async function loadAlarms() {
            if (!selectedDate) {
                console.log('⚠️ loadAlarms: No hay fecha seleccionada');
                return [];
            }

            try {
                const events = await getEventsForDate(selectedDate);
                // Buscar la nota del usuario actual
                const note = events.find(event => event.type === 'note' && event.userId === currentUserId);

                if (note && note.alarms && Array.isArray(note.alarms)) {
                    alarms = note.alarms;
                    console.log(`✅ Alarmas del usuario actual cargadas: ${alarms.length} alarmas para ${formatDateKey(selectedDate)}`);
                    console.log('📋 Contenido de alarmas cargadas:', JSON.stringify(alarms));
                } else {
                    alarms = [];
                    if (note) {
                        console.log(`ℹ️ Nota del usuario actual encontrada pero sin alarmas para ${formatDateKey(selectedDate)}`);
                    } else {
                        console.log(`ℹ️ No se encontró nota del usuario actual para ${formatDateKey(selectedDate)}`);
                    }
                }
                updateAlarmCount();
                return alarms;
            } catch (error) {
                console.error('❌ Error cargando alarmas:', error);
                alarms = [];
                return alarms;
            }
        }

        // Actualizar el contador de alarmas
        function updateAlarmCount() {
            const alarmNumber = document.getElementById('alarmNumber');
            if (alarmNumber) {
                alarmNumber.textContent = alarms.length;
            }
        }

        // Abrir modal de alarma
        async function openAlarmModal() {
            // Cargar alarmas existentes
            await loadAlarms();

            // Establecer fecha por defecto al día seleccionado
            if (selectedDate) {
                const dateStr = selectedDate.toISOString().split('T')[0];
                document.getElementById('alarmDateInput').value = dateStr;
            }

            // Limpiar hora
            document.getElementById('alarmTimeInput').value = '';

            // Mostrar alarmas existentes
            renderAlarmsList();

            // Mostrar el modal
            document.getElementById('alarmModal').classList.add('show');
        }

        // Cerrar modal de alarma
        function closeAlarmModal() {
            document.getElementById('alarmModal').classList.remove('show');
        }

        // Manejar clic fuera del modal
        function handleAlarmModalClick(event) {
            if (event.target.id === 'alarmModal') {
                closeAlarmModal();
            }
        }

        // Renderizar lista de alarmas
        function renderAlarmsList() {
            const alarmList = document.getElementById('alarmList');
            alarmList.innerHTML = '';

            if (alarms.length === 0) {
                alarmList.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">No hay alarmas configuradas</div>';
                return;
            }

            alarms.forEach((alarm, index) => {
                const item = document.createElement('div');
                item.className = 'alarm-item';

                const date = new Date(alarm.dateTime);
                const dateStr = date.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: '2-digit' });
                const timeStr = date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });

                item.innerHTML = `
                    <div class="alarm-item-info">
                        <div class="alarm-item-date">${dateStr}</div>
                        <div class="alarm-item-time">${timeStr}</div>
                    </div>
                    <button class="alarm-item-delete" onclick="deleteAlarm(${index})">×</button>
                `;

                alarmList.appendChild(item);
            });
        }

        // Agregar alarma
        async function addAlarm() {
            const dateInput = document.getElementById('alarmDateInput').value;
            const timeInput = document.getElementById('alarmTimeInput').value;

            if (!dateInput || !timeInput) {
                console.warn('⚠️ Por favor completa fecha y hora');
                return;
            }

            // Crear objeto de fecha y hora
            const dateTime = new Date(`${dateInput}T${timeInput}`);

            // Verificar que la fecha no sea en el pasado
            if (dateTime < new Date()) {
                console.warn('⚠️ No se puede configurar una alarma en el pasado');
                return;
            }

            // Agregar alarma a la lista
            const alarm = {
                dateTime: dateTime.toISOString(), // Guardar como string ISO para Firebase
                id: Date.now().toString() // ID único para la alarma (como string)
            };

            alarms.push(alarm);
            console.log('➕ Alarma agregada:', JSON.stringify(alarm));

            // Guardar alarmas en Firebase
            await saveAlarms();

            // Limpiar inputs
            document.getElementById('alarmTimeInput').value = '';

            // Actualizar lista
            renderAlarmsList();
            updateAlarmCount();
        }

        // Eliminar alarma
        async function deleteAlarm(index) {
            if (index >= 0 && index < alarms.length) {
                alarms.splice(index, 1);
                await saveAlarms();
                renderAlarmsList();
                updateAlarmCount();
            }
        }

        // Guardar alarmas en Firebase
        async function saveAlarms() {
            if (!selectedDate) return;

            try {
                const existingEvents = await getEventsForDate(selectedDate);
                // Buscar la nota del usuario actual
                const existingNoteIndex = existingEvents.findIndex(event => event.type === 'note' && event.userId === currentUserId);

                if (existingNoteIndex !== -1) {
                    // Actualizar nota existente con alarmas, preservando todos los demás campos
                    const existingNote = existingEvents[existingNoteIndex];
                    existingEvents[existingNoteIndex] = {
                        ...existingNote, // Preservar todos los campos existentes
                        alarms: alarms,
                        updatedAt: new Date().toISOString()
                    };
                    console.log('✅ Nota del usuario actual actualizada con alarmas:', alarms.length, 'alarmas');
                    console.log('📋 Contenido de alarmas:', JSON.stringify(alarms));
                } else {
                    // Crear nota con alarmas
                    const noteEvent = {
                        text: '',
                        userId: currentUserId,
                        userColor: getUserColor(currentUserId),
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        categories: [],
                        alarms: alarms,
                        type: 'note',
                        textSize: 11 // Tamaño por defecto
                    };
                    existingEvents.push(noteEvent);
                    console.log('✅ Nueva nota del usuario actual creada con alarmas:', alarms.length, 'alarmas');
                }

                await saveEvents(selectedDate, existingEvents);
                console.log('✅ Alarmas guardadas en Firebase:', alarms.length);

                // Verificar que se guardaron correctamente
                const verifyEvents = await getEventsForDate(selectedDate);
                const verifyNote = verifyEvents.find(event => event.type === 'note' && event.userId === currentUserId);
                if (verifyNote && verifyNote.alarms) {
                    console.log('✅ Verificación: Alarmas guardadas correctamente:', verifyNote.alarms.length);
                    console.log('📋 Alarmas verificadas:', JSON.stringify(verifyNote.alarms));
                } else {
                    console.warn('⚠️ Advertencia: No se encontraron alarmas del usuario actual después de guardar');
                }

                // Guardar también en localStorage para verificación local (especialmente iOS)
                saveAlarmsToLocalStorage();

                // Configurar notificaciones y programar en Service Worker
                setupAlarmNotifications();
                if (!isIOS) {
                    scheduleAllAlarms();
                } else {
                    // En iOS, programar en localStorage para verificación cuando la app se abre
                    scheduleAlarmsForIOS();
                    console.log('ℹ️ iOS: Alarmas programadas para verificación cuando la app se abra');
                }
            } catch (error) {
                console.error('❌ Error guardando alarmas:', error);
            }
        }

        // Programar todas las alarmas en el Service Worker
        async function scheduleAllAlarms() {
            if (!('serviceWorker' in navigator)) return;

            try {
                const registration = await navigator.serviceWorker.ready;
                const now = new Date();

                // Obtener todas las alarmas de los próximos 30 días
                for (let i = 0; i < 30; i++) {
                    const checkDate = new Date(now);
                    checkDate.setDate(checkDate.getDate() + i);

                    try {
                        const events = await getEventsForDate(checkDate);
                        // Obtener todas las notas (múltiples usuarios pueden tener notas)
                        const notes = events.filter(event => event.type === 'note');

                        notes.forEach(note => {
                            if (note && note.alarms && Array.isArray(note.alarms)) {
                                note.alarms.forEach(alarm => {
                                    const alarmDate = new Date(alarm.dateTime);
                                    const timeUntilAlarm = alarmDate.getTime() - now.getTime();

                                    // Solo programar alarmas futuras (próximas 30 días)
                                    if (timeUntilAlarm > 0 && timeUntilAlarm <= 30 * 24 * 60 * 60 * 1000) {
                                        const alarmDateStr = alarmDate.toISOString().split('T')[0];
                                        const alarmTimeStr = alarmDate.toTimeString().split(' ')[0].slice(0, 5);
                                        const noteText = note.text || '';
                                        const noteUser = users.find(u => u.id === note.userId);
                                        const userName = noteUser ? noteUser.name : 'Usuario';

                                        // Enviar mensaje al Service Worker para programar la alarma
                                        const message = {
                                            type: 'SCHEDULE_ALARM',
                                            alarmDate: alarmDateStr,
                                            alarmTime: alarmTimeStr,
                                            noteText: noteText,
                                            userName: userName,
                                            alarmId: alarm.id
                                        };

                                        if (registration.active) {
                                            registration.active.postMessage(message);
                                        } else if (registration.waiting) {
                                            registration.waiting.postMessage(message);
                                            // Activar el SW waiting si es posible
                                            registration.waiting.addEventListener('statechange', function () {
                                                if (registration.waiting.state === 'activated') {
                                                    registration.waiting.postMessage(message);
                                                }
                                            });
                                        } else {
                                            // Si no hay SW activo, guardar el mensaje para cuando esté listo
                                            registration.addEventListener('updatefound', () => {
                                                const newWorker = registration.installing;
                                                if (newWorker) {
                                                    newWorker.addEventListener('statechange', () => {
                                                        if (newWorker.state === 'activated' && navigator.serviceWorker.controller) {
                                                            navigator.serviceWorker.controller.postMessage(message);
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    }
                                });
                            }
                        });
                    } catch (error) {
                        // Continuar con el siguiente día si hay error
                        continue;
                    }
                }

                console.log('✅ Alarmas programadas en Service Worker');
            } catch (error) {
                console.error('❌ Error programando alarmas en SW:', error);
            }
        }

        // Guardar alarmas en localStorage para verificación cuando la app se abre
        function saveAlarmsToLocalStorage() {
            try {
                // Obtener todas las alarmas de los próximos 30 días
                const allAlarms = [];
                const now = new Date();

                // Guardar timestamp de última verificación
                localStorage.setItem('last_alarm_check', now.toISOString());

                const alarmsData = {
                    lastSaved: now.toISOString(),
                    alarms: alarms, // Alarmas del día actual
                    version: '2.0'
                };
                localStorage.setItem('pending_alarms', JSON.stringify(alarmsData));
                console.log('💾 Alarmas guardadas en localStorage para verificación local');
            } catch (error) {
                console.error('Error guardando alarmas en localStorage:', error);
            }
        }

        // Detectar cuando la app vuelve al primer plano (iOS)
        function setupVisibilityChangeListener() {
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    // La app volvió al primer plano
                    console.log('📱 App vuelta al primer plano - verificando alarmas pendientes');

                    // Verificar inmediatamente alarmas que pudieron haberse perdido
                    setTimeout(() => {
                        checkPendingAlarmsOnStart();
                        checkAlarms();
                    }, 500);
                } else {
                    // La app se fue a segundo plano - guardar estado
                    console.log('📱 App en segundo plano - guardando estado');
                    saveAlarmsToLocalStorage();
                }
            });

            // También detectar cuando la ventana recibe foco
            window.addEventListener('focus', () => {
                console.log('📱 Ventana recibió foco - verificando alarmas');
                setTimeout(() => {
                    checkPendingAlarmsOnStart();
                    checkAlarms();
                }, 500);
            });
        }

        // Configurar prompt de instalación para Android
        let deferredPrompt = null;

        function setupAndroidInstallPrompt() {
            // Escuchar el evento beforeinstallprompt (Android Chrome)
            window.addEventListener('beforeinstallprompt', (e) => {
                console.log('📱 Evento beforeinstallprompt recibido');
                e.preventDefault();
                deferredPrompt = e;
                showAndroidInstallButton();
            });

            // Verificar si ya está instalada
            if (isStandaloneMode || window.matchMedia('(display-mode: standalone)').matches) {
                console.log('✅ App ya está instalada como PWA');
                hideAndroidInstallButton();
            }
        }

        // Mostrar botón de instalación en Android
        function showAndroidInstallButton() {
            // Verificar si ya existe el botón
            let installBtn = document.getElementById('androidInstallBtn');

            if (!installBtn && deferredPrompt) {
                installBtn = document.createElement('button');
                installBtn.id = 'androidInstallBtn';
                installBtn.innerHTML = '📱 Instalar App';
                installBtn.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #4CAF50;
                    color: white;
                    border: none;
                    padding: 12px 24px;
                    border-radius: 25px;
                    font-size: 14px;
                    font-weight: bold;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    z-index: 10000;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-family: inherit;
                `;

                installBtn.addEventListener('click', async () => {
                    if (!deferredPrompt) return;

                    // Mostrar el prompt de instalación
                    deferredPrompt.prompt();

                    // Esperar respuesta del usuario
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log('Usuario eligió:', outcome);

                    if (outcome === 'accepted') {
                        console.log('✅ Usuario aceptó instalar la app');
                    } else {
                        console.log('❌ Usuario rechazó instalar la app');
                    }

                    deferredPrompt = null;
                    hideAndroidInstallButton();
                });

                document.body.appendChild(installBtn);
            }
        }

        // Ocultar botón de instalación
        function hideAndroidInstallButton() {
            const installBtn = document.getElementById('androidInstallBtn');
            if (installBtn) {
                installBtn.remove();
            }
        }

        // Verificar si la app está instalada como PWA
        function checkPWAInstallation() {
            // Verificar si se está ejecutando en modo standalone (PWA instalada)
            const isStandalone = isStandaloneMode ||
                window.matchMedia('(display-mode: standalone)').matches ||
                (window.navigator.standalone === true) ||
                document.referrer.includes('android-app://');

            if (isStandalone) {
                console.log('✅ PWA instalada detectada - mejores capacidades disponibles');
                // Cuando está instalada como PWA, puede tener más permisos
                if ('Notification' in window && Notification.permission === 'default') {
                    Notification.requestPermission();
                }
                hideAndroidInstallButton();
            } else if (isIOS) {
                console.log('ℹ️ Para mejor funcionalidad en iPhone, instala la app:');
                console.log('   1. Toca el botón Compartir (cuadrado con flecha)');
                console.log('   2. Selecciona "Añadir a pantalla de inicio"');
                console.log('   3. Abre la app desde el icono en la pantalla de inicio');

                // Mostrar un mensaje visual la primera vez
                const hasSeenPWAMessage = localStorage.getItem('pwa_install_message_seen');
                if (!hasSeenPWAMessage && isIOS) {
                    setTimeout(() => {
                        const pwaHint = document.createElement('div');
                        pwaHint.style.cssText = `
                            position: fixed;
                            bottom: 20px;
                            left: 10px;
                            right: 10px;
                            background: #FF9800;
                            color: white;
                            padding: 15px;
                            border-radius: 10px;
                            z-index: 10000;
                            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                            font-size: 14px;
                            line-height: 1.5;
                        `;
                        pwaHint.innerHTML = `
                            <strong>💡 Mejora las alarmas en iPhone:</strong><br>
                            Instala esta app tocando <strong>Compartir</strong> → <strong>"Añadir a pantalla de inicio"</strong>
                            <button onclick="this.parentElement.remove(); localStorage.setItem('pwa_install_message_seen', 'true');" 
                                    style="float: right; margin-top: 5px; background: white; color: #FF9800; border: none; padding: 5px 10px; border-radius: 5px; font-weight: bold; cursor: pointer;">
                                ✕
                            </button>
                        `;
                        document.body.appendChild(pwaHint);
                    }, 3000);
                }
            }

            return isStandalone;
        }

        // Programar alarmas para iOS usando localStorage (para verificación cuando la app se abre)
        async function scheduleAlarmsForIOS() {
            try {
                const now = new Date();
                const scheduledAlarms = [];

                // Obtener todas las alarmas de los próximos 7 días
                for (let i = 0; i < 7; i++) {
                    const checkDate = new Date(now);
                    checkDate.setDate(checkDate.getDate() + i);

                    try {
                        const events = await getEventsForDate(checkDate);
                        // Obtener todas las notas (múltiples usuarios)
                        const notes = events.filter(event => event.type === 'note');

                        notes.forEach(note => {
                            if (note && note.alarms && Array.isArray(note.alarms)) {
                                note.alarms.forEach(alarm => {
                                    const alarmDate = new Date(alarm.dateTime);
                                    const timeUntilAlarm = alarmDate.getTime() - now.getTime();

                                    // Solo programar alarmas futuras
                                    if (timeUntilAlarm > 0) {
                                        scheduledAlarms.push({
                                            id: alarm.id,
                                            dateTime: alarm.dateTime,
                                            date: alarmDate.toISOString().split('T')[0],
                                            time: alarmDate.toTimeString().split(' ')[0].slice(0, 5),
                                            noteText: note.text || '',
                                            userId: note.userId
                                        });
                                    }
                                });
                            }
                        });
                    } catch (error) {
                        continue;
                    }
                }

                // Guardar en localStorage para verificación cuando la app se abre
                localStorage.setItem('ios_scheduled_alarms', JSON.stringify({
                    alarms: scheduledAlarms,
                    lastUpdated: now.toISOString()
                }));

                console.log(`✅ ${scheduledAlarms.length} alarmas programadas para verificación en iOS`);
            } catch (error) {
                console.error('Error programando alarmas para iOS:', error);
            }
        }

        // Verificar alarmas pendientes al abrir la app (especialmente importante para iOS)
        async function checkPendingAlarmsOnStart() {
            try {
                const now = new Date();
                const checkedAlarmIds = new Set();
                let foundAlarms = false;

                // Obtener última verificación
                const lastCheck = localStorage.getItem('last_alarm_check');
                const lastCheckTime = lastCheck ? new Date(lastCheck) : null;

                // Si no hay última verificación, buscar en las últimas 24 horas
                const checkRange = lastCheckTime ?
                    Math.max(1, Math.ceil((now - lastCheckTime) / (1000 * 60 * 60))) : 24; // Horas

                console.log(`🔍 Verificando alarmas perdidas (últimos ${checkRange} horas o 7 días)`);

                // Verificar alarmas de los últimos 7 días (o desde última verificación)
                const daysToCheck = Math.min(7, Math.ceil(checkRange / 24) + 1);

                for (let i = 0; i < daysToCheck; i++) {
                    const checkDate = new Date(now);
                    checkDate.setDate(checkDate.getDate() - i); // Verificar días pasados también

                    try {
                        const events = await getEventsForDate(checkDate);
                        // Obtener todas las notas (múltiples usuarios)
                        const notes = events.filter(event => event.type === 'note');

                        notes.forEach(note => {
                            if (note && note.alarms && Array.isArray(note.alarms)) {
                                note.alarms.forEach(alarm => {
                                    if (checkedAlarmIds.has(alarm.id)) return;
                                    checkedAlarmIds.add(alarm.id);

                                    const alarmDate = new Date(alarm.dateTime);
                                    const diff = alarmDate.getTime() - now.getTime();

                                    // Si la alarma era en el pasado (se perdió mientras la app estaba cerrada)
                                    // Verificar desde la última verificación o máximo 30 minutos atrás
                                    const maxTimeBack = lastCheckTime ?
                                        (now - lastCheckTime) : (30 * 60 * 1000); // 30 minutos por defecto

                                    if (diff < 0 && diff > -maxTimeBack) {
                                        console.log(`🔔 Alarma perdida detectada: ${alarm.id} (hace ${Math.round(-diff / 1000)}s)`);
                                        foundAlarms = true;
                                        const noteText = note.text || '';

                                        // Mostrar notificación inmediatamente
                                        setTimeout(() => {
                                            showAlarmNotification(alarm, noteText);
                                        }, 100);
                                    }
                                });
                            }
                        });
                    } catch (error) {
                        continue;
                    }
                }

                // Verificar también alarmas programadas en localStorage (iOS)
                if (isIOS) {
                    const iosAlarms = localStorage.getItem('ios_scheduled_alarms');
                    if (iosAlarms) {
                        try {
                            const data = JSON.parse(iosAlarms);
                            data.alarms.forEach(alarm => {
                                if (checkedAlarmIds.has(alarm.id)) return;
                                checkedAlarmIds.add(alarm.id);

                                const alarmDate = new Date(alarm.dateTime);
                                const diff = alarmDate.getTime() - now.getTime();

                                const maxTimeBack = lastCheckTime ?
                                    (now - lastCheckTime) : (30 * 60 * 1000);

                                if (diff < 0 && diff > -maxTimeBack) {
                                    console.log(`🔔 Alarma iOS perdida detectada: ${alarm.id}`);
                                    foundAlarms = true;

                                    setTimeout(() => {
                                        showAlarmNotification({ id: alarm.id, dateTime: alarm.dateTime }, alarm.noteText);
                                    }, 100);
                                }
                            });
                        } catch (e) {
                            console.error('Error verificando alarmas iOS:', e);
                        }
                    }
                }

                // Actualizar timestamp de última verificación
                localStorage.setItem('last_alarm_check', now.toISOString());

                if (!foundAlarms) {
                    console.log('✅ No se encontraron alarmas perdidas');
                } else {
                    console.log('⚠️ Alarmas perdidas encontradas y mostradas');
                }
            } catch (error) {
                console.error('Error verificando alarmas pendientes:', error);
            }
        }

        // Configurar notificaciones de alarmas
        function setupAlarmNotifications() {
            // Limpiar notificaciones anteriores
            clearInterval(window.alarmCheckInterval);

            // Verificar alarmas cada minuto (o cada 30 segundos en móviles para mejor respuesta)
            const checkInterval = isMobile ? 30000 : 60000;

            window.alarmCheckInterval = setInterval(() => {
                checkAlarms();
            }, checkInterval);

            console.log(`⏰ Verificación de alarmas cada ${checkInterval / 1000} segundos (${isMobile ? 'móvil' : 'escritorio'})`);

            // Verificar inmediatamente
            checkAlarms();
        }

        // Verificar si alguna alarma debe activarse
        async function checkAlarms() {
            const now = new Date();
            const checkedAlarmIds = new Set(); // Para evitar duplicados
            let totalAlarmsChecked = 0;

            try {
                // Verificar alarmas del día actual y los próximos 7 días
                for (let i = 0; i < 7; i++) {
                    const checkDate = new Date(now);
                    checkDate.setDate(checkDate.getDate() + i);
                    const dateKey = formatDateKey(checkDate);

                    try {
                        const events = await getEventsForDate(checkDate);
                        // Obtener todas las notas (múltiples usuarios)
                        const notes = events.filter(event => event.type === 'note');

                        notes.forEach(note => {
                            if (note && note.alarms && Array.isArray(note.alarms)) {
                                console.log(`🔍 Verificando ${note.alarms.length} alarmas para ${dateKey}`);

                                note.alarms.forEach(alarm => {
                                    // Evitar verificar la misma alarma dos veces
                                    if (checkedAlarmIds.has(alarm.id)) return;
                                    checkedAlarmIds.add(alarm.id);
                                    totalAlarmsChecked++;

                                    const alarmDate = new Date(alarm.dateTime);
                                    const diff = alarmDate.getTime() - now.getTime();

                                    console.log(`⏰ Alarma ${alarm.id}: fecha=${alarmDate.toISOString()}, diff=${Math.round(diff / 1000)}s`);

                                    // Si la alarma es ahora o en los próximos 60 segundos
                                    if (diff >= 0 && diff <= 60000) {
                                        console.log(`🔔 ¡ALARMA ACTIVADA! ${alarm.id} - Diferencia: ${Math.round(diff / 1000)}s`);
                                        const noteText = note.text || '';
                                        showAlarmNotification(alarm, noteText);
                                    }
                                });
                            }
                        });
                    } catch (error) {
                        console.error(`Error verificando alarmas para ${dateKey}:`, error);
                        // Continuar con el siguiente día si hay error
                        continue;
                    }
                }

                if (totalAlarmsChecked > 0) {
                    console.log(`✅ Verificación completada: ${totalAlarmsChecked} alarmas verificadas`);
                }
            } catch (error) {
                console.error('❌ Error verificando alarmas:', error);
            }
        }

        // Mostrar notificación de alarma
        async function showAlarmNotification(alarm, alarmNoteText = '') {
            const alarmDate = new Date(alarm.dateTime);
            const dateStr = alarmDate.toISOString().split('T')[0];
            const timeStr = alarmDate.toTimeString().split(' ')[0].slice(0, 5);

            // Obtener texto de la nota si no se proporcionó
            let noteText = alarmNoteText;
            if (!noteText) {
                try {
                    const events = await getEventsForDate(new Date(alarm.dateTime));
                    const note = events.find(event => event.type === 'note');
                    if (note && note.text) {
                        noteText = note.text;
                    }
                } catch (error) {
                    console.error('Error obteniendo nota para alarma:', error);
                }
            }

            // Abrir página de notificación
            openAlarmNotificationPage(dateStr, timeStr, noteText);

            // También mostrar notificación del navegador si está permitido
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    try {
                        const notification = new Notification('🔔 Recordatorio', {
                            body: `Tienes una alarma configurada para ${alarmDate.toLocaleString('es-ES')}`,
                            icon: 'icons/Icon-192.png',
                            tag: `alarm-${alarm.id}`,
                            requireInteraction: true,
                            data: {
                                url: `alarm-notification.html?date=${dateStr}&time=${timeStr}&note=${encodeURIComponent(noteText)}&user=${encodeURIComponent(users.find(u => u.id === currentUserId)?.name || 'Usuario')}`
                            }
                        });

                        notification.onclick = function () {
                            openAlarmNotificationPage(dateStr, timeStr, noteText);
                            window.focus();
                            notification.close();
                        };
                    } catch (error) {
                        console.log('Error mostrando notificación (permiso puede haber sido revocado):', error);
                        // Continuar - la página de alarma ya se abrió
                    }
                } else if (Notification.permission === 'default') {
                    // Solicitar permiso solo si es la primera vez
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            // Si ahora se otorgó el permiso, mostrar notificación
                            try {
                                const notification = new Notification('🔔 Recordatorio', {
                                    body: `Tienes una alarma configurada para ${alarmDate.toLocaleString('es-ES')}`,
                                    icon: 'icons/Icon-192.png',
                                    tag: `alarm-${alarm.id}`,
                                    requireInteraction: true
                                });

                                notification.onclick = function () {
                                    openAlarmNotificationPage(dateStr, timeStr, noteText);
                                    window.focus();
                                    notification.close();
                                };
                            } catch (error) {
                                console.log('Error mostrando notificación después de otorgar permiso:', error);
                            }
                        }
                    });
                }
                // Si el permiso es 'denied', simplemente no mostramos notificación pero sí la página
            }
        }

        // Abrir página de notificación de alarma
        function openAlarmNotificationPage(dateStr, timeStr, noteText) {
            // Obtener nombre del usuario actual
            const currentUser = users.find(u => u.id === currentUserId);
            const userName = currentUser ? currentUser.name : 'Usuario';

            // Construir URL con parámetros
            const params = new URLSearchParams({
                date: dateStr,
                time: timeStr,
                note: encodeURIComponent(noteText || ''),
                user: encodeURIComponent(userName)
            });

            // Abrir en nueva ventana/pestaña o redirigir
            const alarmUrl = `alarm-notification.html?${params.toString()}`;

            console.log('🔔 Abriendo página de alarma:', alarmUrl);

            // En móviles, mejor redirigir directamente en la misma ventana
            if (isMobile) {
                console.log('📱 Dispositivo móvil detectado: redirigiendo a pantalla de alarma');
                window.location.href = alarmUrl;
                return;
            }

            // En escritorio, intentar abrir en nueva ventana
            try {
                // Usar window.open con características específicas para pantalla completa
                const alarmWindow = window.open(
                    alarmUrl,
                    'alarmWindow',
                    'width=' + screen.width + ',height=' + screen.height + ',left=0,top=0,fullscreen=yes'
                );

                if (alarmWindow) {
                    alarmWindow.focus();
                    console.log('✅ Ventana de alarma abierta');
                } else {
                    // Si falla por bloqueo del navegador, redirigir en la misma ventana
                    console.log('⚠️ No se pudo abrir nueva ventana, redirigiendo en la misma ventana');
                    window.location.href = alarmUrl;
                }
            } catch (error) {
                console.error('Error abriendo ventana de alarma:', error);
                // Fallback: redirigir en la misma ventana
                window.location.href = alarmUrl;
            }
        }

        // Obtener categorías seleccionadas
        function getSelectedCategories() {
            const categories = [];
            for (let i = 0; i < 3; i++) {
                // Buscar el dropdown por su ID
                const dropdown = document.getElementById(`dropdown-${i}`);
                if (dropdown) {
                    // Los elementos están en el parentElement del dropdown
                    const dropdownContainer = dropdown.parentElement;
                    const textElement = dropdownContainer.querySelector('.dropdown-text');
                    const iconElement = dropdownContainer.querySelector('.no-icon');

                    console.log(`🔍 Dropdown ${i}:`, {
                        dropdown: dropdown,
                        dropdownContainer: dropdownContainer,
                        textElement: textElement?.textContent,
                        iconElement: iconElement?.textContent
                    });

                    if (textElement && iconElement) {
                        const selectedText = textElement.textContent;
                        const selectedIcon = iconElement.textContent;

                        console.log(`📝 Categoría ${i}: "${selectedText}" con icono "${selectedIcon}"`);

                        if (selectedText !== 'Ninguno' && selectedText.trim() !== '') {
                            categories.push({
                                text: selectedText,
                                icon: selectedIcon
                            });
                            console.log(`✅ Categoría ${i} agregada:`, { text: selectedText, icon: selectedIcon });
                        } else {
                            console.log(`⏭️ Categoría ${i} omitida (Ninguno o vacía)`);
                        }
                    } else {
                        console.log(`❌ No se encontraron elementos para dropdown ${i}`);
                        // Intentar con selectores alternativos
                        const altTextElement = dropdownContainer.querySelector('span.dropdown-text');
                        const altIconElement = dropdownContainer.querySelector('div.no-icon');
                        console.log(`🔄 Selectores alternativos:`, {
                            altTextElement: altTextElement?.textContent,
                            altIconElement: altIconElement?.textContent
                        });
                    }
                } else {
                    console.log(`❌ No se encontró dropdown ${i}`);
                }
            }
            console.log('📋 Categorías finales:', categories);
            return categories;
        }

        // Aceptar cambios del día
        async function acceptDayChanges() {
            const mainText = document.getElementById('mainTextarea').value;
            const selectedCategories = getSelectedCategories();

            console.log('✅ Cambios aceptados para el día:', selectedDate);
            console.log('📝 Nota principal:', mainText);
            console.log('🏷️ Categorías seleccionadas:', selectedCategories);

            try {
                // Obtener eventos existentes del día
                const existingEvents = await getEventsForDate(selectedDate);

                // Buscar si ya existe una nota del usuario actual para este día
                const existingNoteIndex = existingEvents.findIndex(event => event.type === 'note' && event.userId === currentUserId);

                if (mainText.trim() === '') {
                    // Si no hay texto, eliminar la nota existente del usuario actual
                    if (existingNoteIndex !== -1) {
                        existingEvents.splice(existingNoteIndex, 1);
                        console.log('🗑️ Nota del usuario actual eliminada');
                    }
                } else {
                    // Crear o actualizar la nota del usuario actual
                    // Preservar textSize, alarmas y hora existentes si existen
                    const existingNote = existingNoteIndex !== -1 ? existingEvents[existingNoteIndex] : null;
                    const noteEvent = {
                        text: mainText.trim(),
                        userId: currentUserId,
                        userColor: getUserColor(currentUserId),
                        createdAt: existingNoteIndex !== -1 ? existingEvents[existingNoteIndex].createdAt : new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        categories: selectedCategories,
                        type: 'note',
                        // Preservar textSize si existe, si no usar el por defecto
                        textSize: existingNote && existingNote.textSize ? existingNote.textSize : 11,
                        // Preservar alarmas si existen
                        alarms: existingNote && existingNote.alarms && Array.isArray(existingNote.alarms) ? existingNote.alarms : [],
                        // Preservar hora si existe
                        time: existingNote && existingNote.time ? existingNote.time : undefined,
                        // Preservar privacidad si existe
                        private: existingNote && existingNote.private ? existingNote.private : false,
                        // Preservar usuarios visibles si existe
                        visibleTo: existingNote && existingNote.visibleTo ? existingNote.visibleTo : undefined
                    };

                    if (existingNoteIndex !== -1) {
                        // Actualizar nota existente del usuario actual
                        existingEvents[existingNoteIndex] = noteEvent;
                        console.log('✏️ Nota del usuario actual actualizada con textSize:', noteEvent.textSize, 'y alarmas:', noteEvent.alarms.length);
                    } else {
                        // Crear nueva nota del usuario actual
                        existingEvents.push(noteEvent);
                        console.log('📝 Nueva nota del usuario actual creada con textSize:', noteEvent.textSize);
                    }
                }

                // Guardar en Firebase
                await saveEvents(selectedDate, existingEvents);

                console.log('✅ Cambios guardados en Firebase');

            } catch (error) {
                console.error('❌ Error guardando cambios:', error);
            }

            closeModal();
        }

        // Toggle dropdown
        function toggleDropdown(index) {
            // Cerrar todos los otros dropdowns
            for (let i = 0; i < 3; i++) {
                if (i !== index) {
                    const dropdown = document.getElementById(`dropdown-${i}`);
                    dropdown.classList.remove('show');
                }
            }

            // Toggle el dropdown actual
            const dropdown = document.getElementById(`dropdown-${index}`);
            dropdown.classList.toggle('show');
        }

        // Seleccionar categoría
        async function selectCategory(index, text, icon) {
            const dropdown = document.querySelector(`#dropdown-${index}`);
            const dropdownText = dropdown.parentElement.querySelector('.dropdown-text');
            const dropdownIcon = dropdown.parentElement.querySelector('.no-icon');

            // Actualizar texto e icono
            dropdownText.textContent = text;
            dropdownIcon.textContent = icon || '🚫';

            // Cerrar dropdown
            dropdown.classList.remove('show');

            console.log(`✅ Categoría ${index + 1} seleccionada:`, text);

            // Guardar categorías inmediatamente en Firebase
            await saveCategoriesToFirebase();
        }

        // Guardar categorías en Firebase inmediatamente
        async function saveCategoriesToFirebase() {
            if (!selectedDate || !isFirebaseConnected) {
                console.log('⚠️ No se puede guardar categorías - selectedDate:', selectedDate, 'isFirebaseConnected:', isFirebaseConnected);
                return;
            }

            try {
                const selectedCategories = getSelectedCategories();
                console.log('📝 Categorías seleccionadas:', selectedCategories);

                // Obtener eventos existentes del día
                const existingEvents = await getEventsForDate(selectedDate);
                console.log('📅 Eventos existentes:', existingEvents);

                // Buscar si ya existe una nota del usuario actual para este día
                const existingNoteIndex = existingEvents.findIndex(event => event.type === 'note' && event.userId === currentUserId);
                console.log('🔍 Índice de nota del usuario actual existente:', existingNoteIndex);

                if (existingNoteIndex !== -1) {
                    // Actualizar categorías de la nota existente del usuario actual
                    existingEvents[existingNoteIndex].categories = selectedCategories;
                    existingEvents[existingNoteIndex].updatedAt = new Date().toISOString();

                    console.log('✏️ Actualizando nota del usuario actual existente con categorías:', existingEvents[existingNoteIndex]);

                    // Guardar en Firebase
                    await saveEvents(selectedDate, existingEvents);
                    console.log('✅ Categorías guardadas en Firebase inmediatamente');
                } else {
                    // Si no hay nota del usuario actual, crear una temporal solo con categorías
                    const noteEvent = {
                        text: '', // Nota vacía
                        userId: currentUserId,
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString(),
                        categories: selectedCategories,
                        type: 'note'
                    };

                    console.log('📝 Creando nueva nota del usuario actual con categorías:', noteEvent);

                    existingEvents.push(noteEvent);
                    await saveEvents(selectedDate, existingEvents);
                    console.log('✅ Categorías guardadas en Firebase (nota temporal del usuario actual creada)');
                }

            } catch (error) {
                console.error('❌ Error guardando categorías:', error);
            }
        }

        // Cerrar dropdowns al hacer clic fuera
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.category-dropdown')) {
                for (let i = 0; i < 3; i++) {
                    const dropdown = document.getElementById(`dropdown-${i}`);
                    dropdown.classList.remove('show');
                }
            }
        });

        // Agregar evento
        async function addEvent() {
            const select = document.getElementById('shiftSelect');
            const text = select.value.trim();

            if (!text) {
                console.warn('⚠️ Por favor selecciona un turno');
                return;
            }

            const events = await getEventsForDate(selectedDate);
            events.push({
                text: text,
                userId: currentUserId,
                createdAt: new Date().toISOString()
            });

            await saveEvents(selectedDate, events);
            await openDayModal(selectedDate); // Refrescar modal
            select.value = '';
        }

        // Eliminar evento
        async function deleteEvent(index) {
            const events = await getEventsForDate(selectedDate);
            events.splice(index, 1);
            await saveEvents(selectedDate, events);
            await openDayModal(selectedDate); // Refrescar modal
        }

        // Volver a selector de usuarios (solo si NO está en modo standalone)
        function goBack() {
            // En modo standalone de iOS, no redirigir (podría causar que se abra Safari)
            if (isIOS && isStandaloneMode) {
                console.log('⚠️ En modo standalone, no se puede redirigir a iphone.html');
                return;
            }
            window.location.href = 'iphone.html';
        }

        // Cerrar modal al hacer clic fuera
        document.getElementById('dayModal').addEventListener('click', function (e) {
            if (e.target === this) {
                closeModal();
            }
        });

        // Función para agregar eventos de prueba (deshabilitada)
        async function addTestEvents() {
            // Datos de prueba deshabilitados - usar Firebase
            console.log('ℹ️ Datos de prueba deshabilitados - usando Firebase');
        }

        // Mostrar turnos
        function showShifts() {
            window.location.href = 'shifts.html';
        }

        // Inicializar cuando cargue la página
        // IMPORTANTE: Para iOS standalone, evitar cualquier retraso o redirección
        // Verificar modo standalone ANTES de cualquier otra cosa
        (function () {
            // Si estamos en iOS standalone, inicializar inmediatamente
            if (isIOS && (window.navigator.standalone === true)) {
                console.log('🚀 iOS Standalone detectado - inicializando inmediatamente');
                // Inicializar lo antes posible
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        setTimeout(init, 0);
                    });
                } else {
                    setTimeout(init, 0);
                }
                return;
            }

            // Para otros casos, usar la inicialización normal
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                setTimeout(init, 0);
            } else {
                document.addEventListener('DOMContentLoaded', init);
            }

            // También escuchar el evento load como backup
            window.addEventListener('load', () => {
                if (!window.calendarInitialized && !isInitialized) {
                    window.calendarInitialized = true;
                    init();
                }
            }, { once: true });
        })();

        // Asegurar que los botones de acción sean visibles
        window.addEventListener('DOMContentLoaded', () => {
            const bottomActions = document.querySelector('.bottom-actions');
            if (bottomActions) {
                bottomActions.style.display = 'flex';
                bottomActions.style.visibility = 'visible';
                bottomActions.style.opacity = '1';
                console.log('✅ Botones de acción asegurados como visibles');
            } else {
                console.error('❌ No se encontró la barra de botones');
            }
        });

        // Script de depuración para verificar botones
        setTimeout(() => {
            const bottomActions = document.querySelector('.bottom-actions');
            console.log('🔍 Estado de los botones:', {
                elemento: bottomActions,
                display: bottomActions ? getComputedStyle(bottomActions).display : 'N/A',
                visibility: bottomActions ? getComputedStyle(bottomActions).visibility : 'N/A',
                opacity: bottomActions ? getComputedStyle(bottomActions).opacity : 'N/A',
                height: bottomActions ? getComputedStyle(bottomActions).height : 'N/A',
                zIndex: bottomActions ? getComputedStyle(bottomActions).zIndex : 'N/A',
            });
        }, 1000);

        // ==========================================
        // FUNCIONES PARA MODAL DE USUARIO (FIX IPHONE)
        // ==========================================
        function openUserSelector() {
            const listContainer = document.getElementById('userSelectionList');
            if (listContainer && typeof users !== 'undefined') {
                listContainer.innerHTML = '';
                users.forEach(user => {
                    const isSelected = user.id === currentUserId;
                    const div = document.createElement('div');
                    div.className = `user-option ${isSelected ? 'selected' : ''}`;
                    div.onclick = () => selectUserFromApp(user.id);
                    div.innerHTML = `
                        <div class="user-option-avatar" style="background-color: ${user.color}">
                            ${user.name ? user.name.charAt(0) : '?'}
                        </div>
                        <div class="user-option-info">
                            <div class="user-option-name">${user.name}</div>
                        </div>
                        ${isSelected ? '<div class="user-option-check">✓</div>' : ''}
                    `;
                    listContainer.appendChild(div);
                });
            }
            const modal = document.getElementById('userModal');
            if (modal) modal.style.display = 'flex'; // Usar display flex para mostrar
        }

        function closeUserModal() {
            const modal = document.getElementById('userModal');
            if (modal) modal.style.display = 'none';
        }

        async function selectUserFromApp(userId) {
            if (userId === currentUserId) {
                closeUserModal();
                return;
            }
            currentUserId = userId;
            localStorage.setItem('current_user_id', String(userId));
            closeUserModal();

            // Actualizar en Firebase
            if (isFirebaseConnected && db) {
                try {
                    const userRef = db.collection('users').doc(String(userId));
                    await userRef.set({
                        lastSelected: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });
                } catch (e) { console.error('Error updating usage', e); }
            }

            console.log(`Usuario cambiado a ID: ${userId}`);
            // Recargar datos y renderizar
            await init();
        }

        // Cerrar al click fuera
        document.getElementById('userModal')?.addEventListener('click', function (e) {
            if (e.target === this) closeUserModal();
        });
    </script>
</body>

</html>